{"title":"Dia-04","markdown":{"yaml":{"title":"Dia-04"},"headingText":"Modelos lineares funcionais","headingAttr":{"id":"secao-4","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r, echo=FALSE}\n\nknitr::opts_chunk$set(fig.align = 'center', out.width=\"100%\", fig.retina = 2, warning = FALSE, message = FALSE)\n\npacman::p_load(tidyverse, lme4, mgcv, refund, face, fda, rgl, fields, refund.shiny, janitor)\n\n```\n\n\nOs modelos lineares funcionais são uma classe de modelos estatísticos que lidam com dados funcionais, ou seja, observações que são representadas como funções contínuas ao invés de valores numéricos isolados. Esses modelos são amplamente utilizados para análise de dados funcionais em várias áreas, como biologia, economia, engenharia e ciências da saúde.\n\nA ideia básica por trás dos modelos lineares funcionais é estender a estrutura dos modelos lineares tradicionais para acomodar dados funcionais. Em um modelo linear funcional, a variável de resposta é modelada como uma combinação linear de funções base, onde os coeficientes de regressão indicam o efeito das funções base na resposta. Essas funções base podem ser pré-determinadas, como funções polinomiais ou splines, ou podem ser obtidas de forma adaptativa a partir dos próprios dados, por exemplo, usando a Análise de Componentes Principais Funcionais (fPCA).\n\nAjustar um modelo linear funcional envolve estimar os coeficientes de regressão e possivelmente outros parâmetros do modelo, como a variância do erro. Diversas técnicas de estimação estão disponíveis para modelos lineares funcionais, incluindo mínimos quadrados ponderados, estimação por máxima verossimilhança e métodos baseados em penalização.\n\nUma vantagem dos modelos lineares funcionais é que eles permitem modelar a estrutura temporal dos dados e capturar a variabilidade e dependência funcional ao longo do tempo. Isso torna esses modelos particularmente adequados para dados longitudinais ou séries temporais, onde a variação e a relação entre as observações podem mudar ao longo do tempo.\n\nEm resumo, os modelos lineares funcionais são uma poderosa ferramenta estatística para análise de dados funcionais, permitindo modelar e interpretar relações entre variáveis em um contexto funcional e temporal.\n\n# Tópicos de hoje:\n\n-   Regressão de escalar em função - SoF (pfr)\n\n-   Regressão de componentes principais funcionais (FPC)\n\n-   Modelo linear funcional com base restrita\n\n-   Gráficos interativos (plot_shiny) para regressão de escalar em função\n\n-   Função em escalar - FoS (pffr)\n\n-   Função em função - FoF (pffr)\n\n-   Modelos lineares funcionais simultâneos\n\n\\[Código fornecido por cortesia de Arnab Maity\\]\n\n## 1 Scalar-on-function regression model\n\n\"Scalar-on-function regression model\" pode ser traduzido como \"modelo de regressão escalar em função\". Nesse contexto, \"scalar\" se refere a um valor único, enquanto \"function\" se refere a uma função matemática que pode variar de acordo com uma variável independente. Portanto, um \"scalar-on-function regression model\" é um modelo de regressão que visa prever um valor único (escalar) com base em uma função variável.\n\n```{r, warning=FALSE, message=FALSE}\n\nmarathon_results_2017 <-readr::read_csv(\"marathon_results_2017.csv\")\n\n\nmarathon_df <- marathon_results_2017 %>% \ndplyr::select(-c(`...1`,\n            Bib,City,\n            State,\n            Country,\n            Citizen,\n            `...10`,\n            Division,\n            Gender,\n            Overall,\n            `Proj Time`)) %>% \n  janitor::clean_names()\n\nmutate_seconds <- function(x){\n  lubridate::hour(x)* 3600 + lubridate::minute(x) * 60 + lubridate::second(x) *1\n}\n  \n\n marathon_df <- \n   marathon_df %>% \n        drop_na() %>% \n        mutate(\n          across(starts_with(c(\"x\",\"half\")), lubridate::hms),\n          across(starts_with(c(\"x\",\"half\",\"pace\", \"official_time\")), mutate_seconds),\n          `5` = (5000/ `x5k`)*3.6,\n          `10` = (10000/ `x10k`)*3.6,\n          `15` = (15000/ `x15k`)*3.6,\n          `20` = (20000/ `x20k`)*3.6,\n          `21` = (21000/ half)*3.6,\n          `25` = (25000/ `x25k`)*3.6,\n          `30` = (30000/ `x30k`)*3.6,\n          `35` = (35000/ `x35k`)*3.6,\n          `40` = (40000/ `x40k`)*3.6,\n          `42` = (42000/ official_time)*3.6\n            ) %>% \n   rename(\n     names = name\n   )\n \n \nmarathon_df %>% \n  dplyr::filter(m_f == \"M\") %>%\n  dplyr::slice(1:150) %>% \n  pivot_longer(cols = 15:24) %>% \n  mutate(\n    name = as.numeric(name)\n  ) %>% \n  group_by(name) %>% \n  ggplot(aes(name,value, group = names, color = m_f))+\n  geom_line(alpha = 0.7, color = \"grey\")+\n  #geom_point(color = \"black\", alpha = 0.7)+\n  ylab(\"Velocidade Km/h\")+\n  xlab(\"Km de maratona\")+\n  ggtitle(\"Maratona - Velocidade\")\n```\n\nPergunta de interesse: Existe alguma relação entre o tempo total decorrido e o ritmo da corrida (perfis de milhas por minuto)?\n\nAgora podemos responder a essas perguntas usando o modelo de regressão linear funcional com resposta escalar e covariável funcional! (SoF)\n\nLembrando:\n\n$$\nY_i = \\mu_Y + \\int X_i(t) \\beta(t) dt + \\epsilon_i,\n$$\n\nonde Xi é modelado usando fPCA, $X_i = \\mu(t) + \\sum_{i=1}^{n} \\sum_{k=1}^{\\infty} \\xi_{ik}\\phi_{k}(t)t)$\n\nLembrando que fPCA se refere à Análise de Componentes Principais Funcionais (Functional Principal Component Analysis) e $\\mu(t)$ é a média da função, ξᵢₖ são os coeficientes de PCA e $\\phi_k(t)$ são as funções de base de PCA.\n\n## 1.1 Regressão de componentes principais funcionais (FPC)\n\nAqui ilustramos o ajuste de regressão linear funcional assumindo $\\beta(t) = \\sum_{i=1}^{n} \\sum_{k=1}^{\\infty} \\beta_{k}\\phi_{k}(t)$. Primeiro carregamos o conjunto de dados e definimos a resposta e a covariável.\n\n### Primeiro passo\n\nO primeiro passo da estimativa é executar o fPCA na covariável funcional usando um dos softwares que implementam o fPCA (módulo 3); por exemplo, fpca.ssvd, fpca.face e fpca.sc no pacote refund / pca.fd no pacote fda / fpca.mle no pacote fpca / PACE no Matlab.\n\n```{r}\nspeed <- marathon_df %>% \n    dplyr::filter(m_f == \"M\") %>% \n    dplyr::select(15:24) %>% \n    dplyr::slice(1:150) %>% \n      as.matrix()\n\nkms <- c(5,10,15,20,21,25,30,35,40,42)\n\nfinal_time <-\n  marathon_df %>% \n  dplyr::filter(m_f == \"M\") %>%\n  dplyr::slice(1:150) %>% \n  dplyr::select(official_time) %>%  \n  as.matrix()\n\nfpca_res <- fpca.face(Y= speed ,pve = 0.97, argvals = kms, knots = 6)\n\n#fpca_res <- fpca.sc(X, argvals = miles, pve = 0.97)\n\nm <- length(kms)\nefn <- fpca_res$efunctions*sqrt(m)\neval <- fpca_res$evalues/m\nscr <- fpca_res$scores/sqrt(m)\nnpc <- fpca_res$npc\n\n\ncbind(kms,efn) %>% \n  as_tibble() %>% \n  rename(\n    pc1 = V2,\n    pc2 = V3\n  ) %>% \n  pivot_longer(cols = starts_with(\"pc\")) %>% \n  group_by(kms) %>% \n  ggplot(aes(kms,value,group = name, color = name))+\n  geom_line()+\n  labs(x=\"km\",y=\"\", title = \"Autofunções estimadas\" )\n```\n\n```{r}\nk.pc <- 1\neffect <- sqrt(eval[k.pc])*efn[,k.pc]\nmu_hat <- fpca_res$mu\n\n\ncbind(kms,efn[,k.pc]) %>% \n  as_tibble() %>% \n  ggplot(aes(kms, V2))+\n  geom_line()+\n  ylim(c(-2,2))+\n  labs(x=\"km\",y=\"\", title = \"fCP-1\" )\n\n\nmu_hat %>% \n  as_tibble_col(column_name = \"mu.hat\") %>% \n  mutate(\n    effect_Plus = mu.hat + effect,\n    effect_less = mu.hat - effect,\n    kms = kms\n  ) %>% \n  pivot_longer(cols = 1:3) %>% \n  group_by(kms) %>% \n  ggplot(aes(kms, value, group = name, color = name))+\n  geom_line()+\n  labs(x=\"km\",y=\"\", title = \"fCP-1\")\n\n```\n\n(Atividade para fazer em casa) Experimente o gráfico interativo dos resultados do fPCA (plot_shiny(fpca_res)) e interprete. (Módulo 3-3)\n\n### Passo dois\n\nAgora, usando a matriz de escores estimados, faça uma regressão linear múltipla no vetor de respostas escalares $Y$ (tempo de conclusão). Obtenha os coeficientes estimados, $\\beta_j$'s.\n\n```{r}\nout = lm(final_time ~ scr) ## Multiple linear regression\n# summary(out)\nbeta_hat = out$coefficients\nbeta_hat\n\nsummary(out)\n\n```\n\nUma vez que o fPCA selecionou os três primeiros componentes principais com base na porcentagem especificada da variância explicada, temos aqui três coeficientes de base correspondentes.\n\nAgora, para reconstruir a função do coeficiente de regressão,\n\n```{r}\nbeta_fn_hat = efn %*% as.matrix(beta_hat[-1], col = 1) \n\ncbind(kms,beta_fn_hat) %>% \n  as_tibble() %>% \n  ggplot(aes(kms,V2))+\n  geom_line()+\n  ylim(c(-2000,800))+\n  ylab(\"\")\n\n\n```\n\nComo podemos dar sentido ao coeficiente? Vamos nos concentrar em analisar três perfis de velocidade aleatórios:\n\n```{r}\nset.seed(12)\nn.crv <- 3\nn <- nrow(speed)\nsel.crv <- sample(1:n, size=n.crv, replace = FALSE)\n\nrand_speed <- t(fpca_res$Yhat[sel.crv,])\n\ncbind(kms,rand_speed) %>% \n  as_tibble() %>% \n  pivot_longer(cols = contains(\"V\")) %>% \n  group_by(kms) %>% \n  ggplot(aes(kms,value,group = name,color=name))+\n  geom_line()+\n  ylab(\"\")\n\n\npar(mfrow=c(3,3))\nfor(i in 1:3){\n  ind <- sel.crv[i]\n  demeaned <- fpca_res$Yhat[ind,]-as.vector(fpca_res$mu)\n  \n  matplot(kms, t(fpca_res$Yhat[sel.crv,]-t(matrix(rep(fpca_res$mu,3), nrow=10))), \n          type='l', lwd=2, lty=1, col = 'light grey',\n          xlab=\"miles\", ylab=\"speed (demeaned)\", main=\"\")\n  lines(kms, demeaned, type='l', lwd=2, col='red')\n  \n  \n  plot(kms, beta_fn_hat, type='l', lwd=2,\n       xlab=\"miles\", ylab = \"estimated coefficient fn\", main=\"\")\n  plot(kms, demeaned*beta_fn_hat,type='l', lwd=2, col='blue',\n       xlab=\"miles\", ylab = \"\", ylim=c(-55, 70),\n       main=round(mean(demeaned*beta_fn_hat), 2))\n}\n```\n\nPor último, vamos analisar a bondade de ajuste estimada.\n\n```{r}\npar(mfrow=c(1,1))\nplot(final_time, out$fitted, cex=0.5, ylab=\"Fitted\", xlab=\"Observed\")\nabline(a = 0, b = 1)\n\n\nRsq = 1-sum((out$residuals)^2)/sum((final_time- mean(final_time))^2)\nRsq\n```\n\nExistem várias funções integradas que podem ajustar um modelo linear funcional usando fPCA: a função PACE-REG no pacote Matlab PACE; a função pfr no pacote refund; a função fRegress no pacote fda.\n\nVantagens: computacionalmente simples e aplicável a qualquer design de amostragem. Desvantagens: forte pressuposto de que $\\beta(\\cdot)$ e $X(\\cdot)$ estão no mesmo espaço e têm uma suavidade similar.\n\n## 2 Modelo linear funcional com base mista\n\nPara superar algumas limitações do método anterior, Goldsmith et al. (2011) propuseram modelar a função de coeficiente $\\beta(\\cdot)$) usando uma função de base truncada; no entanto, outras funções de base também são aplicáveis.\n\nLembre-se de que, ao modelar $X(\\cdot)$ usando eigenfunções e $\\beta(\\cdot)$ usando funções de base pré-definidas, temos -\n\n$$\nY_i = \\alpha + \\xi^T_i J \\beta,\n$$\n\nonde $\\boldsymbol{\\xi}_i = [ \\xi_{i1}, \\xi_{i2}, \\ldots, \\xi_{iK} ]^T, J$ é uma matriz $K \\times L$ com o elemento $(k,ℓ)-th$ dado por $J_{k\\ell} = \\int \\phi_k(t)\\theta_\\ell(t) dt$, e $\\boldsymbol{\\beta} = [ \\beta_1, \\beta_2, \\ldots, \\beta_K ]^T$.\n\nEste modelo pode ser ajustado usando a função pfr no pacote refund. (Novamente, usamos \"milhas por minuto\" e \"tempo de conclusão\" como covariável e resposta)\n\n```{r}\nX <- as.matrix(speed) # functional covariate\nY <- final_time    # scalar response\n\n\nmyDat <- data.frame(X, Y)\n\nfit <- pfr(Y ~ lf(X, k = 10, bs = \"cr\"), method = \"REML\", data = myDat)\ncoef <- coef(fit)\n\n\ncbind(coef$X.argvals, coef$value) %>% \n  as_tibble() %>% \n  ggplot(aes(V1,V2))+\n  geom_line()+\n  labs(x = \"km\", y=expression(paste(beta(t))), title = \"função de coeficiente estimado\")\n```\n\n```{r}\npar(mfrow=c(3,3))\n\nbeta_fn_hat0 <- beta_fn_hat  # saving beta(t) from fPCA approach\n\nfit <- pfr(Y ~ lf(X, k = 10, bs = \"cr\"), method = \"REML\", data = myDat)\ncoef <- coef(fit)\nbeta_fn_hat <- coef$value\n\nfor(i in 1:3){\n  ind <- sel.crv[i]\n  demeaned <- fpca_res$Yhat[ind,]-as.vector(fpca_res$mu)\n  \n  matplot(kms, t(fpca_res$Yhat[sel.crv,]-t(matrix(rep(fpca_res$mu,3), nrow=10))), \n          type='l', lwd=2, lty=1, col = 'light grey',\n          xlab=\"miles\", ylab=\"speed (demeaned)\", main=\"\")\n  lines(kms, demeaned, type='l', lwd=2, col='red')\n  \n  \n  plot(kms, beta_fn_hat, type='l', lwd=2,\n       xlab=\"miles\", ylab = \"estimated coefficient fn\", main=\"\")\n  plot(kms, demeaned*beta_fn_hat,type='l', lwd=2, col='blue',\n       xlab=\"miles\", ylab = \"\", main=round(mean(demeaned*beta_fn_hat), 2)) \n}\n\n```\n\n```{r}\npar(mfrow=c(1,1))\nplot( rowSums( sapply(1:2, function(a) (t(efn) %*% beta_fn_hat/10)[a] * efn[,a]) ) , type='l', lwd=2, col = \"red\", ylab=\"\", xlab=\"miles\")\nlines(kms, beta_fn_hat0, type='l', lwd=2)\n```\n\nO comando `plot(fit)` plota a função de coeficientes estimada com intervalo de confiança ponto a ponto, o que NÃO é útil para inferência! Uma possível maneira de construir um intervalo de confiança conjunto é por meio do método de bootstrap.\n\n```{r}\nfpca_res <- fpca.face(X ,pve = 0.97, argvals = kms, knots = 6)\nXhat <- fpca_res$Yhat\nYhat <- predict(fit, newdata = list(X = Xhat))\n\n# goodness-of-fit\npar(mfrow=c(1,1))\nplot(Y, Yhat, cex=0.5, ylab=\"Fitted\", xlab=\"Observed\")\nabline(a = 0, b = 1)\n\nRsq = 1-sum((Y- as.vector(Yhat))^2)/sum((Y - mean(Y))^2)\nRsq\n\n```\n\nA função pfr é flexível para adicionar mais de uma covariável funcional e/ou escalar; por exemplo, `pfr(Y ~ X0 + lf(X1) + lf(X2))` para ajustar.\n\n$$\nY_i = \\mu_Y + \\beta_0 X_0 + \\int X_{1i}(t) \\beta_1(t) dt + \\int X_{2i}(t) \\beta_2(t) dt + \\epsilon_i.\n$$\n\nAlém disso, também pode ser usado para ajustar regressão funcional não linear,\n\n$$\nY_i = \\mu_Y + \\int F\\{X_i(t), t\\} dt + \\epsilon_i.\n$$\n\nonde $F(\\cdot,\\cdot)$ é uma função suave bivariada desconhecida;\n\n```{r}\n#fit <- pfr(Y ~ af(X, k = c(10, 8), bs = \"cr\"))\n\nfit <- pfr(Y ~ af(X, k = c(10, 8), bs = \"cr\"))\ncoef <- coef(fit)\n\nplot(fit$fitted.values,Y)\nabline(a = 0, b = 1)\n```\n\n## 3 Regressão de Função em Escalar (FoS)\n\nA regressão de função em escalar (FoS) é uma abordagem estatística que lida com a relação entre uma função e uma variável escalar. Nesse tipo de análise, a variável de interesse é uma função contínua ao longo de uma dimensão, como o tempo, enquanto a variável preditora é uma única medida numérica.\n\nA FoS tem várias aplicações em diferentes campos, como medicina, economia, ecologia e engenharia. Por exemplo, na medicina, pode ser usado para estudar a relação entre o perfil de expressão gênica (função) e uma variável clínica (escalar), como a gravidade de uma doença.\n\nUma das principais vantagens da FoS é que ela permite modelar a relação entre a função e a variável escalar de forma flexível, capturando padrões complexos e não lineares. Isso é especialmente útil quando a relação entre as duas variáveis é esperada para variar ao longo da dimensão da função.\n\nExistem várias abordagens e métodos para realizar a regressão de função em escalar, incluindo o uso de bases funcionais, como splines, wavelets e Fourier, além de técnicas específicas, como regressão de spline penalizada e modelos de mistura.\n\nEm resumo, a regressão de função em escalar é uma ferramenta poderosa para explorar e modelar a relação entre funções e variáveis escalares, permitindo uma análise mais detalhada e flexível dos dados em várias áreas de estudo.\n\nNeste estudo, serão utilizados dados meteorológicos do Canadá para fins de análise.\n\n```{r}\ndata(\"CanadianWeather\")\n\n# Temperature data\ndaily_avg_temp <- \n    CanadianWeather$dailyAv %>% \n    as_tibble() %>% \n    dplyr::select(contains(\"Temperature\")) %>% \n    janitor::clean_names()\n\n\n# temperature plot\ndaily_avg_temp %>% \n  mutate(\n    day = 1:365\n  ) %>% \n  pivot_longer(cols = contains(\"Temperature\")) %>% \n  group_by(day) %>% \n  ggplot(aes(day,value, group = name, color = name)) + \n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )\n\n# precipitation data\ndaily_avg_prec <-\n      CanadianWeather$dailyAv %>% \n      as_tibble() %>% \n      dplyr::select(contains(\"Precipitation\")) %>% \n      janitor::clean_names()\n\n# precipitation plot\ndaily_avg_prec %>% \n  mutate(\n    day = 1:365\n  ) %>% \n  pivot_longer(cols = contains(\"Precipitation\")) %>% \n  group_by(day) %>% \n  ggplot(aes(day,value, group = name, color = name)) + \n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )\n \n\n\n# Total avg data \ntotal_avg_prec <- \n  daily_avg_prec %>% \n  pivot_longer(\n    cols = contains(\"Precipitation\")\n    ) %>% \n  group_by(fct_inorder(name)) %>% \n  summarise(\n    avg_mm = sum(value)\n  ) %>% \n  rename(\n    name = `fct_inorder(name)`\n  ) %>% \n  mutate(\n     name = str_remove(name,\"_precipitation_mm\")\n   ) \n\n\n# Total avg plot \ntotal_avg_prec %>% \n  ggplot(aes(fct_inorder(name),avg_mm))+\n  geom_point()+\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+\n  ylim(0,max(total_avg_prec$avg_mm))\n```\n\nQuestão de interesse: Qual é a associação entre a precipitação anual total e a curva de temperatura diária?\n\nPodemos usar um modelo de regressão de função em escalar para responder a essa pergunta:\n\n$$\nTemp_i(t) = \\beta_0(t) + \\beta_1(t) \\cdot TotalPreci + \\epsilon_i(t)\n$$\n\nPrimeiro, definimos nossa variável de resposta e nossa variável preditora.\n\n```{r}\nday <- 1:365\n\nY <- \n  daily_avg_temp %>% \n  as.matrix() %>% \n  t()\n\nX <-\n  total_avg_prec %>% \n  dplyr::select(-name) %>% \n  as_vector()\n\nmyDat <- data.frame(X = X, Y= Y)\n\ndim(Y);length(X)\n```\n\nE ajustamos o modelo de regressão de função em escalar usando a função `pffr`. (A função `pffr` no pacote refund pode ajustar qualquer modelo linear funcional com resposta funcional.)\n\n```{r, warning=FALSE}\n\nfit <- pffr(Y ~ X, data = myDat)\nyhat <- predict(fit, newdata = myDat) \n  \n\nRsq_t <- 1-colSums((Y - yhat)^2) / colSums((Y - colMeans(Y))^2)\nmean(Rsq_t)\n```\n\n```{r, warning=FALSE}\ny_pivot <- Y %>% \n  t() %>% \n  as_tibble() %>% \n  mutate(\n    day = 1:365\n  ) %>% \n  pivot_longer(cols = contains(\"_c\"), values_to = \"true_value\", names_to = \"station\")\n\n\nyhat_pivot <- yhat %>% \n  t() %>% \n  as_tibble() %>% \n  pivot_longer(cols = contains(\"V\"), values_to = \"fitted\", names_to = \"station_fitted\")\n\n\ntibble(y_pivot, yhat_pivot) %>% \n  group_by(day) %>% \n  ggplot(aes(day, true_value, group = station))+\n  geom_line(color = \"gray\")+\n  geom_line(aes(day, fitted, group = station_fitted, color = station_fitted))+\n  theme(\n    legend.position = \"none\"\n  )\n```\n\nA função de coeficientes estimados é:\n\n```{r}\ncoef <- coef(fit)\nbeta0.hat <- coef$smterms$`Intercept(yindex)`$coef\nbeta1.hat <- coef$smterms$`X(yindex)`$coef\n\ntibble(index = beta0.hat$yindex.vec, value = beta0.hat$value) %>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[0](t))), title = \"\")\n\n\ntibble(index = beta1.hat$yindex.vec, value = beta1.hat$value)%>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[1](t))), title = \"\")\n```\n\nOutras funções que podem ajustar regressão de função em escalar são bayes_fosr e fosr no pacote refund e fRegress no pacote fda. Note que a seleção dos parâmetros de suavização não está implementada na função fRegress. Enquanto isso, fosr pode receber tanto uma matriz como um objeto fd do pacote fda, além de poder selecionar parâmetros de suavização ótimos usando diversos métodos, como `GCV`, `REML`, `ML`, entre outros (`?fosr`).\n\n`bayes_fosr` utiliza estimação Bayesiana e `plot_shiny` recebe a saída de `bayes_fosr` para plotagens interativas.\n\n```{r}\n#fit <- bayes_fosr(Y ~ X)\n#plot_shiny(fit)\n```\n\nIsso retorna cinco abas com gráficos interativos:\n\nAba 1: Dados Observados (resposta observada colorida com base na covariável selecionada pelo usuário.)\n\n1)  Aba 2: Valores Ajustados (curvas previstas com diferentes valores da covariável)\n\n2)  Aba 3: Funções de Coeficientes (funções de coeficientes estimadas)\n\n3)  Aba 4: Resíduos (curvas de resíduos coloridas com base em sua profundidade)\n\n(Atividade em grupo) Explore os gráficos interativos.\n\n## 4 Regressão de função em função (FoF) - Modelo Concorrente\n\nA regressão de função em função (FoF) é uma abordagem estatística que permite modelar a relação entre duas funções contínuas ao longo de uma dimensão comum. No contexto do modelo concorrente, a FoF é usada para investigar a relação entre uma função resposta e uma função preditora, ambas observadas na mesma dimensão temporal.\n\nNo modelo concorrente, a função resposta é modelada como uma combinação linear das funções preditoras, ponderadas por coeficientes de regressão desconhecidos. Esses coeficientes indicam como a função resposta é influenciada pelas diferentes características da função preditora.\n\nPara ajustar o modelo FoF concorrente, são utilizadas técnicas estatísticas como mínimos quadrados parciais ou máxima verossimilhança. O objetivo é estimar os coeficientes de regressão para descrever a relação entre as funções resposta e preditora.\n\nO modelo FoF concorrente pode ser aplicado em várias áreas, como ciências ambientais, medicina, economia e engenharia, onde existem dados funcionais coletados ao longo do tempo. Ele fornece uma abordagem flexível para modelar a complexa relação funcional entre duas variáveis observadas em uma dimensão comum.\n\nO modelo de regressão funcional concorrente\n\n$$\nTemp_i(t) = \\beta_0(t) + \\beta_1(t) \\cdot Preci(t) + \\epsilon_i(t)\n$$\n\nrelaciona a temperatura média diária no ponto de tempo atual t com a precipitação média diária no mesmo ponto de tempo t.\n\n```{r}\ndata(\"CanadianWeather\")\n\nday <- 1:365\n# selecionando os dados de temperatura de todas as estações - 365 dias\nY <- t(as.matrix(CanadianWeather$dailyAv[,,1]))\n# criando Fpca com os dados de precipitação\nfit <- fpca.sc(t(as.matrix(CanadianWeather$dailyAv[,,2])), pve=0.99)\n#selecionando os dados ajustados criados pela Fpca\nX <- fit$Yhat \n\n\nmyDat <- list()\nmyDat$X <- X\nmyDat$Y <- Y\n\n# Criando um modelo de regressão usando pffr function\nfit <- pffr(Y ~ X, data = myDat)\nyhat <- predict(fit, newdata = myDat)\nRsq_t <- 1-colSums((Y - yhat)^2) / colSums((Y - colMeans(Y))^2)\nmean(Rsq_t) # erro médio quadratico\n```\n\nEste modelo explica cerca de 77% da variabilidade total. As funções de coeficiente estimadas são:\n\n```{r}\ncoef <- coef(fit)\nbeta0.hat <- coef$smterms$`Intercept(yindex)`$coef\nbeta1.hat <- coef$smterms$`X(yindex)`$coef\n\n\n\ntibble(index = beta0.hat$yindex.vec, value = beta0.hat$value) %>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[0](t))), title = \"\")\n\n\ntibble(index = beta1.hat$yindex.vec, value = beta1.hat$value)%>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[1](t))), title = \"\")\n```\n\nA função `fRegress` no pacote fda também ajusta a regressão funcional concorrente, mas a seleção dos parâmetros de suavização não está implementada na função.\n\nResumo: - Regressão escalar em função - Dados de maratona - Gráficos interativos (plot_shiny) - Regressão de função em escalar e regressão de função em função - Dados meteorológicos do Canadá - Precipitação média como covariável escalar - Precipitação e temperatura como função de localização\n\nAtividades em grupo e individuais: - Analise os dados de DTI usando os modelos de regressão que aprendemos hoje. - Qual é a associação entre os perfis de FA e as pontuações de PASAT de pacientes com esclerose múltipla em sua primeira visita? (regressão escalar em função) - O conjunto de dados também inclui rcst - perfis de FA coletados do trato corticospinal direito. Como essas medidas se relacionam com as medidas de FA ao longo de CCA? - Ajuste um modelo linear funcional com FA ao longo de CCA como resposta e pontuações de PASAT como covariável; experimente diferentes funções R. Discuta os gráficos interativos dos resultados da regressão de função em escalar.\n\nVamos usar o conjunto de dados DTI para ilustrar dados funcionais observados longitudinalmente amanhã. Tente plotar vários perfis observados de um paciente com EM selecionado aleatoriamente. (Atividade individual)\n","srcMarkdownNoYaml":"\n\n```{r, echo=FALSE}\n\nknitr::opts_chunk$set(fig.align = 'center', out.width=\"100%\", fig.retina = 2, warning = FALSE, message = FALSE)\n\npacman::p_load(tidyverse, lme4, mgcv, refund, face, fda, rgl, fields, refund.shiny, janitor)\n\n```\n\n# Modelos lineares funcionais {#secao-4}\n\nOs modelos lineares funcionais são uma classe de modelos estatísticos que lidam com dados funcionais, ou seja, observações que são representadas como funções contínuas ao invés de valores numéricos isolados. Esses modelos são amplamente utilizados para análise de dados funcionais em várias áreas, como biologia, economia, engenharia e ciências da saúde.\n\nA ideia básica por trás dos modelos lineares funcionais é estender a estrutura dos modelos lineares tradicionais para acomodar dados funcionais. Em um modelo linear funcional, a variável de resposta é modelada como uma combinação linear de funções base, onde os coeficientes de regressão indicam o efeito das funções base na resposta. Essas funções base podem ser pré-determinadas, como funções polinomiais ou splines, ou podem ser obtidas de forma adaptativa a partir dos próprios dados, por exemplo, usando a Análise de Componentes Principais Funcionais (fPCA).\n\nAjustar um modelo linear funcional envolve estimar os coeficientes de regressão e possivelmente outros parâmetros do modelo, como a variância do erro. Diversas técnicas de estimação estão disponíveis para modelos lineares funcionais, incluindo mínimos quadrados ponderados, estimação por máxima verossimilhança e métodos baseados em penalização.\n\nUma vantagem dos modelos lineares funcionais é que eles permitem modelar a estrutura temporal dos dados e capturar a variabilidade e dependência funcional ao longo do tempo. Isso torna esses modelos particularmente adequados para dados longitudinais ou séries temporais, onde a variação e a relação entre as observações podem mudar ao longo do tempo.\n\nEm resumo, os modelos lineares funcionais são uma poderosa ferramenta estatística para análise de dados funcionais, permitindo modelar e interpretar relações entre variáveis em um contexto funcional e temporal.\n\n# Tópicos de hoje:\n\n-   Regressão de escalar em função - SoF (pfr)\n\n-   Regressão de componentes principais funcionais (FPC)\n\n-   Modelo linear funcional com base restrita\n\n-   Gráficos interativos (plot_shiny) para regressão de escalar em função\n\n-   Função em escalar - FoS (pffr)\n\n-   Função em função - FoF (pffr)\n\n-   Modelos lineares funcionais simultâneos\n\n\\[Código fornecido por cortesia de Arnab Maity\\]\n\n## 1 Scalar-on-function regression model\n\n\"Scalar-on-function regression model\" pode ser traduzido como \"modelo de regressão escalar em função\". Nesse contexto, \"scalar\" se refere a um valor único, enquanto \"function\" se refere a uma função matemática que pode variar de acordo com uma variável independente. Portanto, um \"scalar-on-function regression model\" é um modelo de regressão que visa prever um valor único (escalar) com base em uma função variável.\n\n```{r, warning=FALSE, message=FALSE}\n\nmarathon_results_2017 <-readr::read_csv(\"marathon_results_2017.csv\")\n\n\nmarathon_df <- marathon_results_2017 %>% \ndplyr::select(-c(`...1`,\n            Bib,City,\n            State,\n            Country,\n            Citizen,\n            `...10`,\n            Division,\n            Gender,\n            Overall,\n            `Proj Time`)) %>% \n  janitor::clean_names()\n\nmutate_seconds <- function(x){\n  lubridate::hour(x)* 3600 + lubridate::minute(x) * 60 + lubridate::second(x) *1\n}\n  \n\n marathon_df <- \n   marathon_df %>% \n        drop_na() %>% \n        mutate(\n          across(starts_with(c(\"x\",\"half\")), lubridate::hms),\n          across(starts_with(c(\"x\",\"half\",\"pace\", \"official_time\")), mutate_seconds),\n          `5` = (5000/ `x5k`)*3.6,\n          `10` = (10000/ `x10k`)*3.6,\n          `15` = (15000/ `x15k`)*3.6,\n          `20` = (20000/ `x20k`)*3.6,\n          `21` = (21000/ half)*3.6,\n          `25` = (25000/ `x25k`)*3.6,\n          `30` = (30000/ `x30k`)*3.6,\n          `35` = (35000/ `x35k`)*3.6,\n          `40` = (40000/ `x40k`)*3.6,\n          `42` = (42000/ official_time)*3.6\n            ) %>% \n   rename(\n     names = name\n   )\n \n \nmarathon_df %>% \n  dplyr::filter(m_f == \"M\") %>%\n  dplyr::slice(1:150) %>% \n  pivot_longer(cols = 15:24) %>% \n  mutate(\n    name = as.numeric(name)\n  ) %>% \n  group_by(name) %>% \n  ggplot(aes(name,value, group = names, color = m_f))+\n  geom_line(alpha = 0.7, color = \"grey\")+\n  #geom_point(color = \"black\", alpha = 0.7)+\n  ylab(\"Velocidade Km/h\")+\n  xlab(\"Km de maratona\")+\n  ggtitle(\"Maratona - Velocidade\")\n```\n\nPergunta de interesse: Existe alguma relação entre o tempo total decorrido e o ritmo da corrida (perfis de milhas por minuto)?\n\nAgora podemos responder a essas perguntas usando o modelo de regressão linear funcional com resposta escalar e covariável funcional! (SoF)\n\nLembrando:\n\n$$\nY_i = \\mu_Y + \\int X_i(t) \\beta(t) dt + \\epsilon_i,\n$$\n\nonde Xi é modelado usando fPCA, $X_i = \\mu(t) + \\sum_{i=1}^{n} \\sum_{k=1}^{\\infty} \\xi_{ik}\\phi_{k}(t)t)$\n\nLembrando que fPCA se refere à Análise de Componentes Principais Funcionais (Functional Principal Component Analysis) e $\\mu(t)$ é a média da função, ξᵢₖ são os coeficientes de PCA e $\\phi_k(t)$ são as funções de base de PCA.\n\n## 1.1 Regressão de componentes principais funcionais (FPC)\n\nAqui ilustramos o ajuste de regressão linear funcional assumindo $\\beta(t) = \\sum_{i=1}^{n} \\sum_{k=1}^{\\infty} \\beta_{k}\\phi_{k}(t)$. Primeiro carregamos o conjunto de dados e definimos a resposta e a covariável.\n\n### Primeiro passo\n\nO primeiro passo da estimativa é executar o fPCA na covariável funcional usando um dos softwares que implementam o fPCA (módulo 3); por exemplo, fpca.ssvd, fpca.face e fpca.sc no pacote refund / pca.fd no pacote fda / fpca.mle no pacote fpca / PACE no Matlab.\n\n```{r}\nspeed <- marathon_df %>% \n    dplyr::filter(m_f == \"M\") %>% \n    dplyr::select(15:24) %>% \n    dplyr::slice(1:150) %>% \n      as.matrix()\n\nkms <- c(5,10,15,20,21,25,30,35,40,42)\n\nfinal_time <-\n  marathon_df %>% \n  dplyr::filter(m_f == \"M\") %>%\n  dplyr::slice(1:150) %>% \n  dplyr::select(official_time) %>%  \n  as.matrix()\n\nfpca_res <- fpca.face(Y= speed ,pve = 0.97, argvals = kms, knots = 6)\n\n#fpca_res <- fpca.sc(X, argvals = miles, pve = 0.97)\n\nm <- length(kms)\nefn <- fpca_res$efunctions*sqrt(m)\neval <- fpca_res$evalues/m\nscr <- fpca_res$scores/sqrt(m)\nnpc <- fpca_res$npc\n\n\ncbind(kms,efn) %>% \n  as_tibble() %>% \n  rename(\n    pc1 = V2,\n    pc2 = V3\n  ) %>% \n  pivot_longer(cols = starts_with(\"pc\")) %>% \n  group_by(kms) %>% \n  ggplot(aes(kms,value,group = name, color = name))+\n  geom_line()+\n  labs(x=\"km\",y=\"\", title = \"Autofunções estimadas\" )\n```\n\n```{r}\nk.pc <- 1\neffect <- sqrt(eval[k.pc])*efn[,k.pc]\nmu_hat <- fpca_res$mu\n\n\ncbind(kms,efn[,k.pc]) %>% \n  as_tibble() %>% \n  ggplot(aes(kms, V2))+\n  geom_line()+\n  ylim(c(-2,2))+\n  labs(x=\"km\",y=\"\", title = \"fCP-1\" )\n\n\nmu_hat %>% \n  as_tibble_col(column_name = \"mu.hat\") %>% \n  mutate(\n    effect_Plus = mu.hat + effect,\n    effect_less = mu.hat - effect,\n    kms = kms\n  ) %>% \n  pivot_longer(cols = 1:3) %>% \n  group_by(kms) %>% \n  ggplot(aes(kms, value, group = name, color = name))+\n  geom_line()+\n  labs(x=\"km\",y=\"\", title = \"fCP-1\")\n\n```\n\n(Atividade para fazer em casa) Experimente o gráfico interativo dos resultados do fPCA (plot_shiny(fpca_res)) e interprete. (Módulo 3-3)\n\n### Passo dois\n\nAgora, usando a matriz de escores estimados, faça uma regressão linear múltipla no vetor de respostas escalares $Y$ (tempo de conclusão). Obtenha os coeficientes estimados, $\\beta_j$'s.\n\n```{r}\nout = lm(final_time ~ scr) ## Multiple linear regression\n# summary(out)\nbeta_hat = out$coefficients\nbeta_hat\n\nsummary(out)\n\n```\n\nUma vez que o fPCA selecionou os três primeiros componentes principais com base na porcentagem especificada da variância explicada, temos aqui três coeficientes de base correspondentes.\n\nAgora, para reconstruir a função do coeficiente de regressão,\n\n```{r}\nbeta_fn_hat = efn %*% as.matrix(beta_hat[-1], col = 1) \n\ncbind(kms,beta_fn_hat) %>% \n  as_tibble() %>% \n  ggplot(aes(kms,V2))+\n  geom_line()+\n  ylim(c(-2000,800))+\n  ylab(\"\")\n\n\n```\n\nComo podemos dar sentido ao coeficiente? Vamos nos concentrar em analisar três perfis de velocidade aleatórios:\n\n```{r}\nset.seed(12)\nn.crv <- 3\nn <- nrow(speed)\nsel.crv <- sample(1:n, size=n.crv, replace = FALSE)\n\nrand_speed <- t(fpca_res$Yhat[sel.crv,])\n\ncbind(kms,rand_speed) %>% \n  as_tibble() %>% \n  pivot_longer(cols = contains(\"V\")) %>% \n  group_by(kms) %>% \n  ggplot(aes(kms,value,group = name,color=name))+\n  geom_line()+\n  ylab(\"\")\n\n\npar(mfrow=c(3,3))\nfor(i in 1:3){\n  ind <- sel.crv[i]\n  demeaned <- fpca_res$Yhat[ind,]-as.vector(fpca_res$mu)\n  \n  matplot(kms, t(fpca_res$Yhat[sel.crv,]-t(matrix(rep(fpca_res$mu,3), nrow=10))), \n          type='l', lwd=2, lty=1, col = 'light grey',\n          xlab=\"miles\", ylab=\"speed (demeaned)\", main=\"\")\n  lines(kms, demeaned, type='l', lwd=2, col='red')\n  \n  \n  plot(kms, beta_fn_hat, type='l', lwd=2,\n       xlab=\"miles\", ylab = \"estimated coefficient fn\", main=\"\")\n  plot(kms, demeaned*beta_fn_hat,type='l', lwd=2, col='blue',\n       xlab=\"miles\", ylab = \"\", ylim=c(-55, 70),\n       main=round(mean(demeaned*beta_fn_hat), 2))\n}\n```\n\nPor último, vamos analisar a bondade de ajuste estimada.\n\n```{r}\npar(mfrow=c(1,1))\nplot(final_time, out$fitted, cex=0.5, ylab=\"Fitted\", xlab=\"Observed\")\nabline(a = 0, b = 1)\n\n\nRsq = 1-sum((out$residuals)^2)/sum((final_time- mean(final_time))^2)\nRsq\n```\n\nExistem várias funções integradas que podem ajustar um modelo linear funcional usando fPCA: a função PACE-REG no pacote Matlab PACE; a função pfr no pacote refund; a função fRegress no pacote fda.\n\nVantagens: computacionalmente simples e aplicável a qualquer design de amostragem. Desvantagens: forte pressuposto de que $\\beta(\\cdot)$ e $X(\\cdot)$ estão no mesmo espaço e têm uma suavidade similar.\n\n## 2 Modelo linear funcional com base mista\n\nPara superar algumas limitações do método anterior, Goldsmith et al. (2011) propuseram modelar a função de coeficiente $\\beta(\\cdot)$) usando uma função de base truncada; no entanto, outras funções de base também são aplicáveis.\n\nLembre-se de que, ao modelar $X(\\cdot)$ usando eigenfunções e $\\beta(\\cdot)$ usando funções de base pré-definidas, temos -\n\n$$\nY_i = \\alpha + \\xi^T_i J \\beta,\n$$\n\nonde $\\boldsymbol{\\xi}_i = [ \\xi_{i1}, \\xi_{i2}, \\ldots, \\xi_{iK} ]^T, J$ é uma matriz $K \\times L$ com o elemento $(k,ℓ)-th$ dado por $J_{k\\ell} = \\int \\phi_k(t)\\theta_\\ell(t) dt$, e $\\boldsymbol{\\beta} = [ \\beta_1, \\beta_2, \\ldots, \\beta_K ]^T$.\n\nEste modelo pode ser ajustado usando a função pfr no pacote refund. (Novamente, usamos \"milhas por minuto\" e \"tempo de conclusão\" como covariável e resposta)\n\n```{r}\nX <- as.matrix(speed) # functional covariate\nY <- final_time    # scalar response\n\n\nmyDat <- data.frame(X, Y)\n\nfit <- pfr(Y ~ lf(X, k = 10, bs = \"cr\"), method = \"REML\", data = myDat)\ncoef <- coef(fit)\n\n\ncbind(coef$X.argvals, coef$value) %>% \n  as_tibble() %>% \n  ggplot(aes(V1,V2))+\n  geom_line()+\n  labs(x = \"km\", y=expression(paste(beta(t))), title = \"função de coeficiente estimado\")\n```\n\n```{r}\npar(mfrow=c(3,3))\n\nbeta_fn_hat0 <- beta_fn_hat  # saving beta(t) from fPCA approach\n\nfit <- pfr(Y ~ lf(X, k = 10, bs = \"cr\"), method = \"REML\", data = myDat)\ncoef <- coef(fit)\nbeta_fn_hat <- coef$value\n\nfor(i in 1:3){\n  ind <- sel.crv[i]\n  demeaned <- fpca_res$Yhat[ind,]-as.vector(fpca_res$mu)\n  \n  matplot(kms, t(fpca_res$Yhat[sel.crv,]-t(matrix(rep(fpca_res$mu,3), nrow=10))), \n          type='l', lwd=2, lty=1, col = 'light grey',\n          xlab=\"miles\", ylab=\"speed (demeaned)\", main=\"\")\n  lines(kms, demeaned, type='l', lwd=2, col='red')\n  \n  \n  plot(kms, beta_fn_hat, type='l', lwd=2,\n       xlab=\"miles\", ylab = \"estimated coefficient fn\", main=\"\")\n  plot(kms, demeaned*beta_fn_hat,type='l', lwd=2, col='blue',\n       xlab=\"miles\", ylab = \"\", main=round(mean(demeaned*beta_fn_hat), 2)) \n}\n\n```\n\n```{r}\npar(mfrow=c(1,1))\nplot( rowSums( sapply(1:2, function(a) (t(efn) %*% beta_fn_hat/10)[a] * efn[,a]) ) , type='l', lwd=2, col = \"red\", ylab=\"\", xlab=\"miles\")\nlines(kms, beta_fn_hat0, type='l', lwd=2)\n```\n\nO comando `plot(fit)` plota a função de coeficientes estimada com intervalo de confiança ponto a ponto, o que NÃO é útil para inferência! Uma possível maneira de construir um intervalo de confiança conjunto é por meio do método de bootstrap.\n\n```{r}\nfpca_res <- fpca.face(X ,pve = 0.97, argvals = kms, knots = 6)\nXhat <- fpca_res$Yhat\nYhat <- predict(fit, newdata = list(X = Xhat))\n\n# goodness-of-fit\npar(mfrow=c(1,1))\nplot(Y, Yhat, cex=0.5, ylab=\"Fitted\", xlab=\"Observed\")\nabline(a = 0, b = 1)\n\nRsq = 1-sum((Y- as.vector(Yhat))^2)/sum((Y - mean(Y))^2)\nRsq\n\n```\n\nA função pfr é flexível para adicionar mais de uma covariável funcional e/ou escalar; por exemplo, `pfr(Y ~ X0 + lf(X1) + lf(X2))` para ajustar.\n\n$$\nY_i = \\mu_Y + \\beta_0 X_0 + \\int X_{1i}(t) \\beta_1(t) dt + \\int X_{2i}(t) \\beta_2(t) dt + \\epsilon_i.\n$$\n\nAlém disso, também pode ser usado para ajustar regressão funcional não linear,\n\n$$\nY_i = \\mu_Y + \\int F\\{X_i(t), t\\} dt + \\epsilon_i.\n$$\n\nonde $F(\\cdot,\\cdot)$ é uma função suave bivariada desconhecida;\n\n```{r}\n#fit <- pfr(Y ~ af(X, k = c(10, 8), bs = \"cr\"))\n\nfit <- pfr(Y ~ af(X, k = c(10, 8), bs = \"cr\"))\ncoef <- coef(fit)\n\nplot(fit$fitted.values,Y)\nabline(a = 0, b = 1)\n```\n\n## 3 Regressão de Função em Escalar (FoS)\n\nA regressão de função em escalar (FoS) é uma abordagem estatística que lida com a relação entre uma função e uma variável escalar. Nesse tipo de análise, a variável de interesse é uma função contínua ao longo de uma dimensão, como o tempo, enquanto a variável preditora é uma única medida numérica.\n\nA FoS tem várias aplicações em diferentes campos, como medicina, economia, ecologia e engenharia. Por exemplo, na medicina, pode ser usado para estudar a relação entre o perfil de expressão gênica (função) e uma variável clínica (escalar), como a gravidade de uma doença.\n\nUma das principais vantagens da FoS é que ela permite modelar a relação entre a função e a variável escalar de forma flexível, capturando padrões complexos e não lineares. Isso é especialmente útil quando a relação entre as duas variáveis é esperada para variar ao longo da dimensão da função.\n\nExistem várias abordagens e métodos para realizar a regressão de função em escalar, incluindo o uso de bases funcionais, como splines, wavelets e Fourier, além de técnicas específicas, como regressão de spline penalizada e modelos de mistura.\n\nEm resumo, a regressão de função em escalar é uma ferramenta poderosa para explorar e modelar a relação entre funções e variáveis escalares, permitindo uma análise mais detalhada e flexível dos dados em várias áreas de estudo.\n\nNeste estudo, serão utilizados dados meteorológicos do Canadá para fins de análise.\n\n```{r}\ndata(\"CanadianWeather\")\n\n# Temperature data\ndaily_avg_temp <- \n    CanadianWeather$dailyAv %>% \n    as_tibble() %>% \n    dplyr::select(contains(\"Temperature\")) %>% \n    janitor::clean_names()\n\n\n# temperature plot\ndaily_avg_temp %>% \n  mutate(\n    day = 1:365\n  ) %>% \n  pivot_longer(cols = contains(\"Temperature\")) %>% \n  group_by(day) %>% \n  ggplot(aes(day,value, group = name, color = name)) + \n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )\n\n# precipitation data\ndaily_avg_prec <-\n      CanadianWeather$dailyAv %>% \n      as_tibble() %>% \n      dplyr::select(contains(\"Precipitation\")) %>% \n      janitor::clean_names()\n\n# precipitation plot\ndaily_avg_prec %>% \n  mutate(\n    day = 1:365\n  ) %>% \n  pivot_longer(cols = contains(\"Precipitation\")) %>% \n  group_by(day) %>% \n  ggplot(aes(day,value, group = name, color = name)) + \n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )\n \n\n\n# Total avg data \ntotal_avg_prec <- \n  daily_avg_prec %>% \n  pivot_longer(\n    cols = contains(\"Precipitation\")\n    ) %>% \n  group_by(fct_inorder(name)) %>% \n  summarise(\n    avg_mm = sum(value)\n  ) %>% \n  rename(\n    name = `fct_inorder(name)`\n  ) %>% \n  mutate(\n     name = str_remove(name,\"_precipitation_mm\")\n   ) \n\n\n# Total avg plot \ntotal_avg_prec %>% \n  ggplot(aes(fct_inorder(name),avg_mm))+\n  geom_point()+\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+\n  ylim(0,max(total_avg_prec$avg_mm))\n```\n\nQuestão de interesse: Qual é a associação entre a precipitação anual total e a curva de temperatura diária?\n\nPodemos usar um modelo de regressão de função em escalar para responder a essa pergunta:\n\n$$\nTemp_i(t) = \\beta_0(t) + \\beta_1(t) \\cdot TotalPreci + \\epsilon_i(t)\n$$\n\nPrimeiro, definimos nossa variável de resposta e nossa variável preditora.\n\n```{r}\nday <- 1:365\n\nY <- \n  daily_avg_temp %>% \n  as.matrix() %>% \n  t()\n\nX <-\n  total_avg_prec %>% \n  dplyr::select(-name) %>% \n  as_vector()\n\nmyDat <- data.frame(X = X, Y= Y)\n\ndim(Y);length(X)\n```\n\nE ajustamos o modelo de regressão de função em escalar usando a função `pffr`. (A função `pffr` no pacote refund pode ajustar qualquer modelo linear funcional com resposta funcional.)\n\n```{r, warning=FALSE}\n\nfit <- pffr(Y ~ X, data = myDat)\nyhat <- predict(fit, newdata = myDat) \n  \n\nRsq_t <- 1-colSums((Y - yhat)^2) / colSums((Y - colMeans(Y))^2)\nmean(Rsq_t)\n```\n\n```{r, warning=FALSE}\ny_pivot <- Y %>% \n  t() %>% \n  as_tibble() %>% \n  mutate(\n    day = 1:365\n  ) %>% \n  pivot_longer(cols = contains(\"_c\"), values_to = \"true_value\", names_to = \"station\")\n\n\nyhat_pivot <- yhat %>% \n  t() %>% \n  as_tibble() %>% \n  pivot_longer(cols = contains(\"V\"), values_to = \"fitted\", names_to = \"station_fitted\")\n\n\ntibble(y_pivot, yhat_pivot) %>% \n  group_by(day) %>% \n  ggplot(aes(day, true_value, group = station))+\n  geom_line(color = \"gray\")+\n  geom_line(aes(day, fitted, group = station_fitted, color = station_fitted))+\n  theme(\n    legend.position = \"none\"\n  )\n```\n\nA função de coeficientes estimados é:\n\n```{r}\ncoef <- coef(fit)\nbeta0.hat <- coef$smterms$`Intercept(yindex)`$coef\nbeta1.hat <- coef$smterms$`X(yindex)`$coef\n\ntibble(index = beta0.hat$yindex.vec, value = beta0.hat$value) %>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[0](t))), title = \"\")\n\n\ntibble(index = beta1.hat$yindex.vec, value = beta1.hat$value)%>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[1](t))), title = \"\")\n```\n\nOutras funções que podem ajustar regressão de função em escalar são bayes_fosr e fosr no pacote refund e fRegress no pacote fda. Note que a seleção dos parâmetros de suavização não está implementada na função fRegress. Enquanto isso, fosr pode receber tanto uma matriz como um objeto fd do pacote fda, além de poder selecionar parâmetros de suavização ótimos usando diversos métodos, como `GCV`, `REML`, `ML`, entre outros (`?fosr`).\n\n`bayes_fosr` utiliza estimação Bayesiana e `plot_shiny` recebe a saída de `bayes_fosr` para plotagens interativas.\n\n```{r}\n#fit <- bayes_fosr(Y ~ X)\n#plot_shiny(fit)\n```\n\nIsso retorna cinco abas com gráficos interativos:\n\nAba 1: Dados Observados (resposta observada colorida com base na covariável selecionada pelo usuário.)\n\n1)  Aba 2: Valores Ajustados (curvas previstas com diferentes valores da covariável)\n\n2)  Aba 3: Funções de Coeficientes (funções de coeficientes estimadas)\n\n3)  Aba 4: Resíduos (curvas de resíduos coloridas com base em sua profundidade)\n\n(Atividade em grupo) Explore os gráficos interativos.\n\n## 4 Regressão de função em função (FoF) - Modelo Concorrente\n\nA regressão de função em função (FoF) é uma abordagem estatística que permite modelar a relação entre duas funções contínuas ao longo de uma dimensão comum. No contexto do modelo concorrente, a FoF é usada para investigar a relação entre uma função resposta e uma função preditora, ambas observadas na mesma dimensão temporal.\n\nNo modelo concorrente, a função resposta é modelada como uma combinação linear das funções preditoras, ponderadas por coeficientes de regressão desconhecidos. Esses coeficientes indicam como a função resposta é influenciada pelas diferentes características da função preditora.\n\nPara ajustar o modelo FoF concorrente, são utilizadas técnicas estatísticas como mínimos quadrados parciais ou máxima verossimilhança. O objetivo é estimar os coeficientes de regressão para descrever a relação entre as funções resposta e preditora.\n\nO modelo FoF concorrente pode ser aplicado em várias áreas, como ciências ambientais, medicina, economia e engenharia, onde existem dados funcionais coletados ao longo do tempo. Ele fornece uma abordagem flexível para modelar a complexa relação funcional entre duas variáveis observadas em uma dimensão comum.\n\nO modelo de regressão funcional concorrente\n\n$$\nTemp_i(t) = \\beta_0(t) + \\beta_1(t) \\cdot Preci(t) + \\epsilon_i(t)\n$$\n\nrelaciona a temperatura média diária no ponto de tempo atual t com a precipitação média diária no mesmo ponto de tempo t.\n\n```{r}\ndata(\"CanadianWeather\")\n\nday <- 1:365\n# selecionando os dados de temperatura de todas as estações - 365 dias\nY <- t(as.matrix(CanadianWeather$dailyAv[,,1]))\n# criando Fpca com os dados de precipitação\nfit <- fpca.sc(t(as.matrix(CanadianWeather$dailyAv[,,2])), pve=0.99)\n#selecionando os dados ajustados criados pela Fpca\nX <- fit$Yhat \n\n\nmyDat <- list()\nmyDat$X <- X\nmyDat$Y <- Y\n\n# Criando um modelo de regressão usando pffr function\nfit <- pffr(Y ~ X, data = myDat)\nyhat <- predict(fit, newdata = myDat)\nRsq_t <- 1-colSums((Y - yhat)^2) / colSums((Y - colMeans(Y))^2)\nmean(Rsq_t) # erro médio quadratico\n```\n\nEste modelo explica cerca de 77% da variabilidade total. As funções de coeficiente estimadas são:\n\n```{r}\ncoef <- coef(fit)\nbeta0.hat <- coef$smterms$`Intercept(yindex)`$coef\nbeta1.hat <- coef$smterms$`X(yindex)`$coef\n\n\n\ntibble(index = beta0.hat$yindex.vec, value = beta0.hat$value) %>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[0](t))), title = \"\")\n\n\ntibble(index = beta1.hat$yindex.vec, value = beta1.hat$value)%>% \n  ggplot(aes(index,value))+\n  geom_line()+\n  labs(x = \"day\", y = expression(paste(beta[1](t))), title = \"\")\n```\n\nA função `fRegress` no pacote fda também ajusta a regressão funcional concorrente, mas a seleção dos parâmetros de suavização não está implementada na função.\n\nResumo: - Regressão escalar em função - Dados de maratona - Gráficos interativos (plot_shiny) - Regressão de função em escalar e regressão de função em função - Dados meteorológicos do Canadá - Precipitação média como covariável escalar - Precipitação e temperatura como função de localização\n\nAtividades em grupo e individuais: - Analise os dados de DTI usando os modelos de regressão que aprendemos hoje. - Qual é a associação entre os perfis de FA e as pontuações de PASAT de pacientes com esclerose múltipla em sua primeira visita? (regressão escalar em função) - O conjunto de dados também inclui rcst - perfis de FA coletados do trato corticospinal direito. Como essas medidas se relacionam com as medidas de FA ao longo de CCA? - Ajuste um modelo linear funcional com FA ao longo de CCA como resposta e pontuações de PASAT como covariável; experimente diferentes funções R. Discuta os gráficos interativos dos resultados da regressão de função em escalar.\n\nVamos usar o conjunto de dados DTI para ilustrar dados funcionais observados longitudinalmente amanhã. Tente plotar vários perfis observados de um paciente com EM selecionado aleatoriamente. (Atividade individual)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"dia04.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","editor":"visual","theme":"superhero","title":"Dia-04"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}