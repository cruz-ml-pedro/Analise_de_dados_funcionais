{"title":"Dia-02","markdown":{"yaml":{"title":"Dia-02"},"headingText":"Modelagem de dados funcionais com expansões de base predefinida","headingAttr":{"id":"secao-2","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r, echo=FALSE}\nknitr::opts_chunk$set(fig.align = 'center', out.width=\"100%\", fig.retina = 2)\n\npacman::p_load(tidyverse, lme4, mgcv, refund, face, fda, rgl, fields, refund.shiny, janitor)\n```\n\n\n## Tópicos dia 2:\n\n-   Construir diferentes funções de base em R\n\n-   Criar dados funcionais\n\n-   Regressão linear em funções de base (OLS)\n\n-   Como escolher o número de funções de base?\n\n-   Como explicar a suavidade na curva subjacente?\n\n    -   métodos do kernel\n    -   Suavização penalizada e seleção do parâmetro de suavização\n\n\\[Os Código são cortesia de Giles Hooker\\]\n\n## 1 Várias funções base:\n\nAs funções base, também conhecidas como funções de base, são utilizadas em análise estatística e modelagem para descrever ou aproximar relações complexas entre variáveis. Elas são usadas como componentes de modelos estatísticos e permitem representar de forma flexível e adequada diferentes padrões de dados.\n\nAs funções base são frequentemente aplicadas em análise de regressão, onde o objetivo é encontrar uma função que relacione uma variável dependente a uma ou mais variáveis independentes. Elas formam uma base para representar o comportamento geral dos dados e permitem expressar as relações entre as variáveis de forma mais simples e interpretável.\n\nExistem diferentes tipos de funções base, sendo as mais comuns:\n\n-   Funções polinomiais: São funções base construídas a partir de polinômios. Geralmente são utilizadas funções polinomiais de grau baixo, como polinômios de primeira e segunda ordem, para ajustar curvas lineares e quadráticas, respectivamente.\n\n-   Funções splines: As funções splines dividem o domínio de interesse em segmentos menores e utilizam polinômios de grau baixo em cada segmento para modelar os dados. Isso permite uma flexibilidade maior na representação de padrões complexos e não lineares.\n\n-   Funções de onda: São funções que se repetem ao longo de um domínio e podem ser usadas para modelar fenômenos periódicos. Exemplos comuns são as funções seno e cosseno.\n\n-   Funções de base radial: São funções que dependem da distância entre pontos de dados e um centro definido. Essas funções são frequentemente utilizadas em problemas de interpolação ou para modelar dados com padrões radiais.\n\nAo escolher as funções base adequadas, é possível capturar diferentes características dos dados e ajustar modelos que se ajustem melhor aos padrões observados. A seleção correta das funções base é um aspecto importante na modelagem estatística, e depende do conhecimento do pesquisador sobre o problema em questão, bem como das características dos dados disponíveis.\n\n### 1.1 Biblioteca fda\n\nA biblioteca fda (Functional Data Analysis) é um pacote em R que fornece funcionalidades para análise de dados funcionais. A análise de dados funcionais é uma área da estatística que lida com dados observados como funções contínuas ao longo de uma dimensão, como séries temporais, curvas suaves ou imagens médicas.\n\nO fda permite a manipulação, visualização, modelagem e análise de dados funcionais de maneira eficiente. Alguns recursos e funcionalidades principais do fda incluem:\n\n-   Representação de dados funcionais: O pacote oferece estruturas de dados adequadas para representar e armazenar dados funcionais, como objetos fd (functional data) e fdata (functional data array).\n\n-   Visualização de dados funcionais: O fda inclui funções para plotagem e visualização de dados funcionais, permitindo a criação de gráficos de séries temporais, curvas suaves e outras representações visuais adequadas para dados funcionais.\n\n-   Análise exploratória: O pacote fornece métodos estatísticos para análise exploratória de dados funcionais, incluindo medidas descritivas, como média, mediana e desvio padrão funcional, além de ferramentas para análise de variabilidade e análise de componentes principais funcionais.\n\n-   Modelagem e ajuste de dados funcionais: O fda oferece métodos para modelar dados funcionais, incluindo regressão funcional, análise de covariância funcional e análise de séries temporais funcionais. Isso permite ajustar modelos estatísticos apropriados aos dados funcionais.\n\n-   Alinhamento e registro de dados funcionais: O pacote inclui funções para alinhar e registrar dados funcionais, que são úteis quando se deseja comparar ou combinar diferentes curvas ou séries temporais funcionais.\n\nA biblioteca fda é uma ferramenta poderosa para análise de dados funcionais e pode ser usada em uma variedade de aplicações, como medicina, economia, engenharia e muitas outras áreas em que os dados são naturalmente representados como funções contínuas.\n\n### 1.2 Bases Monomiais\n\nA função base monomial, do pacote fda, requer o domínio e o número da base. Por exemplo, a base monomial com K=6 funções de base definidas no intervalo \\[0,1\\] pode ser construída da seguinte forma.\n\n```{r}\nbbasis_obj = create.monomial.basis(rangeval=c(0,1), nbasis = 6)\n```\n\nIsso retornará uma saída como \"funções\". Para avaliar as bases criadas, em uma grade de s pontos, podemos:\n\n```{r}\nx <- seq(0,1,length.out=100) # grade de pontos\n\nbbasisevals <- eval.basis(x, bbasis_obj) # avaliando as bases na grade de pontos\n```\n\nPara visualizar as bases monomiais:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbbasisevals1 <- bbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,bbasisevals1, by = \"rowname\")\n\n\nbasis_plot %>%\n    pivot_longer(\n    cols = starts_with(\"monomial\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n    ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  labs(x = \"X\", y = \"fns bases\", title = \"Bases monomiais com k=6\")\n```\n\n### 1.3 Bases de Fourier\n\nA análise de Fourier requer que sejam definidos o domínio, o período de oscilação e o número de funções de base.\n\n```{r}\nx <- seq(0,1,length.out=100)\n\nfbasis_obj <- create.fourier.basis(rangeval=c(0,1), \n                                 nbasis=65, period = 1)\n\nfbasisevals <- eval.basis(x, fbasis_obj)\n```\n\nPara visualizar as bases de Fourier:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nfbasisevals1 <- fbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,fbasisevals1, by = \"rowname\")\n\n# plotando as bases de fourier\nbasis_plot %>%\n dplyr::select(2:5) %>% # escolhendo o número de bases no plot - 2:5 três bases\npivot_longer(\n    cols = starts_with(c(\"sin\",\"co\")),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  labs(x = \"X\", y = \"fns bases\", title = \"Três primeiras bases de Fourie\")\n```\n\n### 1.4 Bases B-Spline\n\nA base B-spline requer o domínio, as funções de base numérica e o grau.\n\n```{r}\nx <- seq(0,1,length.out=100)\n\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                    nbasis=10, norder=4)\n\nbsbasisevals <- eval.basis(x, bsbasis_obj)\n\n\n```\n\nPara visualizar as bases de B-spline:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbsbasisevals1 <- bsbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,bsbasisevals1, by = \"rowname\")\n\n# plotando B-Spline basis\nbasis_plot %>%\ndplyr::select(2:12) %>% \n  pivot_longer(\n    cols = starts_with(\"bspl\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  labs(x = \"X\", y = \"fns bases\", title = \"B-spline cúbica com k=10\")+\n  theme(\n    legend.position = \"none\"\n  )\n \n```\n\nTestando diferentes valores de `nbasis` e/ou `norder`.\n\n```{r}\n# norder =2\nx <- seq(0,1,length.out=100)\n\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                    nbasis=10, norder=2)\n\nbsbasisevals <- eval.basis(x, bsbasis_obj)\n\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbsbasisevals1 <- bsbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,bsbasisevals1, by = \"rowname\")\n\n# plotando B-Spline basis\nbasis_plot %>%\ndplyr::select(2:12) %>% \n  pivot_longer(\n    cols = starts_with(\"bspl\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )+\n  labs(x = \"X\", y = \"fns bases\", title = \"B-spline linear com k=10\")\n```\n\n### 1.5 Outras bases\n\nO pacote fda também oferece a possibilidade de construir outros tipos de bases. Para visualizar a lista de bases disponíveis, você pode digitar ?create.+\"tab\".\n\n## 2 O objeto dados funcionais (FD) do pacote fda\n\nDefinido por uma base de funções e um vetor de coeficientes aleatórios correspondentes, a função fd desempenha o papel de construtor de objetos de dados funcionais.\n\n```{r}\nnb <- 10\ncoef <- rnorm(nb)\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                  nbasis=nb, norder=4)\n\nfd_obj <- fd(coef, bsbasis_obj)\nx <- seq(0,1,length.out = 100)\nfd_eval <- eval.fd(x, fd_obj)\n```\n\nPara visualizar as bases de aleatórias:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n#\nfd_eval1 <- fd_eval %>% \n  as_tibble() %>% \n  rownames_to_column()\n#\nbasis_plot <- left_join(x1,fd_eval1, by = \"rowname\")\n#\n# plotando B-Spline basis\nbasis_plot %>%\n   pivot_longer(\n    cols = starts_with(\"reps\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )+\n  labs(x = \"X\", y = \"fns bases\", title = \"Função aleatória usando B-spline\")\n```\n\nTente executar o código acima várias vezes. Tente também executar o código com um número diferente de funções base, por exemplo nb \\<- 5, nb \\<- 15, nb \\<- 30.\n\nPara gerar (n = 20) múltiplas funções aleatórias você pode criar uma matriz de coeficientes aleatórios com dimensão de #bases por n; por exemplo.\n\n```{r}\nn <- 20 ; nb <- 10\ncoef = matrix(rnorm(n*nb),nb,n)\n# dim(coefs)   # [1]  10 20\n\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                    nbasis=nb, norder=4)\nfd_obj <- fd(coef, bsbasis_obj)\nx <- seq(0,1,length.out = 100)\nfd_eval <- eval.fd(x, fd_obj)\n```\n\nPara visualizar as funções aleatórias:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\n\nfd_eval1 <- fd_eval %>% \n  as_tibble() %>% \n  rownames_to_column()\n\n\nbasis_plot <- left_join(x1,fd_eval1, by = \"rowname\")\n\n\nbasis_plot %>%\n  # select(2:12) %>% # escolhendo o número de bases no plot - 2:5 três bases\n  pivot_longer(\n    cols = starts_with(\"reps\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )+\n  labs(x = \"X\", y = \"fns bases\", title = \"20 Funções aleatórias usando B-spline\")\n```\n\nAlgumas outras funções úteis do pacote fda:\n\n1)  `deriv.fd`: fornece a derivada de um objeto fd (o valor retornado também é um objeto fd); por exemplo. tente `drfd_obj <- deriv.fd(fd_obj, 1)`; `eval.fd(drfd_obj, x)`.\n\n2)  podemos fazer aritmética com os objetos fd; por exemplo. `eval.fd(fd_obj[1]+fd_obj[2], x)`\n\n3)  operações estatísticas; por exemplo. `mean(fd_obj)` ou `std.fd(fd_obj)`\n\n## 3 Regressão linear em funções de base (OLS)\n\nAqui, tentaremos usar diferentes funções básicas para suavizar os dados meteorológicos canadenses, que estão disponíveis no pacote fda.\n\n(Ilustrado com base de Fourier)\n\nVamos nos concentrar na precipitação média diária de Vancouver (transformação log), representada por apenas uma das curvas observadas.\n\n```{r}\n\ndata(\"CanadianWeather\")\n\n#str(CanadianWeather)\n\n#view(CanadianWeather$dailyAv)\n\nmonths <- row.names(CanadianWeather$dailyAv) %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nprecipitation_log <- CanadianWeather$dailyAv %>% \n  as_tibble() %>% \n dplyr::select(contains(c(\"log\"))) %>% \n  rownames_to_column() \n\n\nprecipitation_log <- left_join(months, precipitation_log, by = \"rowname\") %>% \n dplyr::select(-rowname)\n\nprecipitation_log %>% \ndplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_month = as.numeric(day),\n    day_year = 1:nrow(precipitation_log)\n  ) %>% \n  ggplot(aes(day_year, Vancouver.log10precip))+\n  geom_point()+\n  geom_line()+\n  labs(x = \"dia\", y = \"precipitação-log\", title = \"log da precipitação média diária de vancouver\")\n```\n\nAgora vamos tentar suavizar os pontos observados usando a base de Fourier. Para usar a base de Fourier, precisamos definir o domínio, o período e o número da base.\n\n```{r}\nday <- 1:365\nrangval=range(day)\nperiod = 365 \n\nnbasis = 3 \nfbasis=create.fourier.basis(rangval, nbasis=nbasis, period=period)  \nbvals = eval.basis(day, fbasis)\nXbasis =bvals\n```\n\nVamos ajustar um modelo de regressão linear utilizando as funções de base criadas (OLS).\n\n```{r}\nlm.fit = lm(Vancouver.log10precip ~ 0 + Xbasis, data = precipitation_log) \n\n# Visualizando o modelo\n\nlm.fit %>%\n broom::augment() %>% \n  mutate(\n    day_year = 1:365\n  ) %>% \n  ggplot(aes(day_year, `Vancouver.log10precip`))+\n  geom_point()+\n  geom_line(aes(day_year, .fitted), color = \"red\", linewidth = 2, linetype = 1)+\n  labs(x = \"dia\", y = \"precipitação-log\", title = \"Fourier-nbasis = 3\")\n```\n\nCalculando a segunda derivada da curva ajustada.\n\n```{r}\nyfitfd = fd(lm.fit$coefficients,fbasis)  #obtain FD object\nyfit2D = eval.fd(day, yfitfd, 2) # evaluate the 2nd deriv. of the fit at day\n\nyfit2D %>% \n  bind_cols(day) %>%\n  ggplot(aes(`...2`, `...1` ))+\n  geom_line()+\n  theme_classic()+\n  labs(x = \"dia\", y = \"2D precipitação-log\", title = glue::glue(\"Média dos quadrados da 2D log-precp. = \", \n               round(mean(yfit2D^2),2)))\n```\n\nAgora tente o código com nbasis = 13, nbasis = 27 e nbasis = 365. Qual é o efeito de usar diferentes números de bases?\n\n## 4 Como determinar o número de funções de base?\n\nEstudo de simulação (compensação de viés-variância)\n\nPara saber mais sobre o estudo de simulação, [aqui](https://www4.stat.ncsu.edu/~davidian/st810a/simulation_handout.pdf) estão os slides preparados pelo Dr. Davidian.\n\nO exercício de simulação a seguir ilustra a compensação de viés-variância. Vamos nos concentrar em observar o efeito de diferentes escolhas de número de funções de base no viés, variância e erro quadrático médio (MSE).\n\nO viés e a variância do estimador $\\hat{X}(t)$ são dados por:\n\n$$\n\\text{Bias}(\\hat{X}(t)) = E\\{\\hat{X}(t)\\} - X(t), e\n$$\n\n$$\n\\text{Var}(\\hat{X}(t)) =\\mathbb{E}\\left[ \\left( \\hat{X}(t) - \\mathbb{E}\\left[ \\hat{X}(t) \\right] \\right)^2 \\right],\n$$\n\nrespectivamente. Para t fixo, o MSE é definido como:\n\n$$\n\\text{MSE}\\left\\{\\hat{X}(t)\\right\\} = \\mathbb{E}\\left[ \\left( \\hat{X}(t) - \\mathbb{E}\\left[X(t) \\right] \\right)^2 \\right] = \\text{Bias}^2\\{\\hat{X}(t)\\} + \\text{Var}\\{\\hat{X}(t)\\}\n$$\n\nPara uma curva $Y(\\cdot)$ gostaríamos de selecionar o número de funções de base para minimizar o erro quadrado médio integrado, $\\int TMSE\\{\\hat{X}(t)\\} dt.$\n\nPodemos estudar essas estatísticas por meio de simulação. Neste caso, iremos gerar conjuntos de dados simulados que imitam as medições de precipitação realizadas em Vancouver $(l=26)$.\n\nA seguir está um breve esboço do experimento de simulação:\n\n1)  Suavize as medições de precipitação de Vancouver, $Y(t_j)$, usando B-spline e obtenha\n\n-   a curva ajustada, $\\hat{X}_0(\\cdot)$.\n\n-   Os resíduos, $\\epsilon_j = Y(t_j) - \\hat{X}_0(t_j)$.\n\n2)  Assuma que a curva ajustada, $\\hat{X}_0(\\cdot)$, é a \"verdadeira\" curva subjacente, $X(\\cdot)$.\n\n3)  Gere um conjunto de dados simulados adicionando resíduos, $epsilon^*_j$, reamostrados aleatoriamente à curva subjacente \"verdadeira\",$X(\\cdot)$; em outras palavras, obtenha $Y^*_j$ por meio da adição dos resíduos reamostrados à curva subjacente $Y^*_j = X(t_j) + \\epsilon^*_j$.\n\nRepita o Passo 3 para gerar muitos conjuntos de dados simulados!\n\nAjuste cada conjunto de dados simulados usando uma base de Fourier com K funções de base para várias escolhas de K.\n\nPara cada K, calcule o viés, a variância e o MSE.\n\nA seguir, passarei pelo código de simulação para um conjunto de dados simulado. Primeiro, definimos a resposta de interesse.\n\n```{r}\ndata(\"CanadianWeather\")\n\n#str(CanadianWeather)\n\n#view(CanadianWeather$dailyAv)\n\nmonths <- row.names(CanadianWeather$dailyAv) %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nprecipitation <- CanadianWeather$dailyAv %>% \n  as_tibble() %>% \n  dplyr::select(contains(c(\"Precipitation\"))) %>% \n  rownames_to_column() \n\n\nprecipitation <- left_join(months, precipitation, by = \"rowname\") %>% \n  dplyr::select(-rowname)\n\n```\n\nPlotando os dados de precipitação\n\n```{r}\nvancouver_precip <- precipitation %>% \n     dplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n      separate_wider_position(value,c(month = 3,day=2)) %>% \n      mutate(\n         day_year = 1:nrow(precipitation)\n      ) %>% \n      rename(\n        precipitation_mm = Vancouver.Precipitation.mm\n      ) %>% \n      janitor::clean_names() \n      \nvancouver_precip %>% \n  ggplot(aes(day_year, precipitation_mm))+\n  geom_point()\n```\n\nEm seguida, construímos um estimador suave utilizando funções de base B-spline cúbicas penalizadas (Passo 1). Vamos considerar a linha preta como a 'verdade'. Nesse caso, utilizamos a função `gam` (do pacote `mgcv`) para a suavização, a qual será explicada em breve.\n\n```{r}\n\nlibrary(mgcv)\nday <- 1:365\nfit <- gam(vancouver_precip$precipitation_mm ~s(day, k = 10, bs = \"cr\"), method=\"REML\")\n```\n\nPor simplicidade vamos plotar essa curva ajustada usando o pacote `ggplot2`.\n\n```{r}\nvancouver_precip %>% \n  ggplot(aes(day_year, precipitation_mm))+\n  geom_point()+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 10), se = FALSE)\n```\n\nPara gerar um conjunto de dados simulados (Passos 2-3)\n\nVerificando os resíduos do modelo gerado\n\n```{r}\nfit %>% \nbroom::augment() %>% \n  ggplot(aes(.resid))+\n  geom_histogram(bins = 15)+\n  theme_light()\n```\n\n```{r}\nplot_df <- fit %>% \n      broom::augment() %>%\n        as_tibble() %>% \n        janitor::clean_names()\n\nset.seed(420)\nplot_df %>% \n  mutate(\n    Eps.star = sample(resid, size = 365, replace = TRUE),\n    Y.star = fitted + Eps.star\n  ) %>% \n  ggplot(aes(day, Y.star))+\n  geom_point(alpha = 0.7)+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 10), se = FALSE,linewidth = 2)+\n  geom_point(aes(day,vancouver_precip_precipitation_mm), color = \"red\", alpha = 0.7)+\n  geom_point(aes(day,fitted), color = \"green\")\n\n\n# salvando os dados simulados\nsimulated_precip<- plot_df %>% \n          mutate(\n            Eps.star = sample(resid, size = 365, replace = TRUE),\n            Y.star = fitted + Eps.star\n          )\n```\n\nOs pontos em vermelho são os dados originais, em preto os simulados. A linha em azul é o modelo ajustado aos dados ariginais e a linha em verda o modelo ajustado aos dados simulados.\n\nUma vez que geramos o conjunto de dados simulados, faremos a suavização utilizando a função de base de Fourier com K funções de base, para várias escolhas de K. Aqui consideramos 7 valores diferentes; $K = 2 \\cdot \\text{c}(2:8) + 1$\n\n```{r, warning=FALSE}\nK.vec = 2*c(2:8)+1;    # we consider 7 different values of k.\n# K.vec\nt.day <- 1:365\nm <- length(plot_df$resid)\n\nfbasis=create.fourier.basis(rangeval = c(1, 365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\n\nXfit = array(0, c(m, length(K.vec)))\nindex=0\nfor (K in K.vec){\n  index=index+1\n  Xbasis = bvals[, 1:K]\n  lm.fit = lm(Y.star~0+Xbasis, data = simulated_precip)\n  Xfit[,index] = as.vector(lm.fit$fitted.values)\n}\n\n\nXfit_df <- Xfit %>% \n  as_tibble() %>% \n  rename(\n    model_5 = V1,\n    model_7 = V2,\n    model_9 = V3,\n    model_11 = V4,\n    model_13 = V5,\n    model_15 = V6,\n    model_17 = V7\n  ) %>% \n  mutate(\n    day = 1:365\n  )\n\n\nmodels_plot <- left_join(simulated_precip, Xfit_df, by = \"day\") \n\nmodels_plot %>% \n dplyr::select(day,Y.star,vancouver_precip_precipitation_mm,contains(\"model\")) %>% \n  pivot_longer(cols = contains(\"model\")) %>% \n  group_by(day) %>% \n  ggplot(aes(day,value, group = name, color = name))+\n  geom_line(linewidth = 1.5)+\n  geom_point(aes(day, Y.star), color = \"blue\", alpha = 0.7)+\n  geom_point(aes(day, vancouver_precip_precipitation_mm), color = \"red\", alpha = 0.7)\n\n```\n\nAgora, realizamos os passos acima para B=100 conjuntos de dados e calculamos o viés, a variância, o MSE (Erro Quadrático Médio) e o MSE integrado.\n\n```{r}\nK.vec = 2*c(2:8)+1; \nB=100 #B=10000\nm = length(simulated_precip$resid)\nXfit = array(0, c(B, m, length(K.vec)))\nt.day <- simulated_precip$day\n\nfbasis=create.fourier.basis(rangeval = c(1,365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\n# ----\n\nset.seed0=1234\nfor(b in 1:B){#b=1\n  set.seed(set.seed0+b)\n\n  simulated_precip <- plot_df %>% \n      mutate( \n        Eps.star = sample(resid, size = 365, replace = TRUE),\n        Y.star = fitted + Eps.star\n        )\n  \n  # fit using Fourier basis and K basis functions\n  index=0\n  for (k in K.vec){\n    index=index+1\n    Xbasis = bvals[, 1:k]\n    lm.fit = lm(Y.star~0+Xbasis, data = simulated_precip)\n    Xfit[b,,index] = as.vector(lm.fit$fitted.values)\n  }\n}\n\n\nMean.Est = apply(Xfit, c(2,3), mean)\nMean.Est2 = apply(Xfit, c(2,3), function(x) mean(x^2))\n\nXtrue <- simulated_precip$fitted\n\nBias = apply(Mean.Est, 2, function(x) Xtrue-x)\nVar = Mean.Est2 - (Mean.Est)^2\nMse= Bias^2+Var\n\nMean_Bias2_L2 = apply(Bias^2, 2, mean) \nVar_L2 = apply(Var, 2, mean) \nMSE_L2 = apply(Mse, 2, mean)\n\nbases_resid<- bind_cols(bases_number = K.vec,\n          mean_basis2 = Mean_Bias2_L2,\n          var_L2 = Var_L2,\n          MSE_L2 = MSE_L2)\n\nbases_resid %>% \n  pivot_longer(cols = 2:4) %>% \n  group_by(bases_number) %>% \n  ggplot(aes(bases_number, value,group = name, color = name))+\n  geom_line()+\n  geom_point()+\n  labs(x = \"número de funções de base\", y = \"erro quadrático total\")\n```\n\nCross-validation (Validação Cruzada)\n\nUma maneira de escolher o número de funções de base é a validação cruzada.\n\n\\[trecho dos apontamentos de aula :\\]\n\n-   Deixe de fora uma observação $(t_j, Y_j)$.\n-   Ajuste os dados restantes e obtenha $\\hat{X}_j(t_j)$ para várias escolhas de $K$.\n-   Escolha $K$ que minimize o escore de validação cruzada, definido como:\n\n$$CV(X) = \\sum_{j=1}^{m} (Y_j - \\hat{X}_j(t_j))^2$$\n\nEssas são as mesmas medições\n\n```{r}\nvancouver_precip <- precipitation %>% \ndplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_year = 1:nrow(precipitation)\n  ) %>% \n  rename(\n    precipitation_mm = Vancouver.Precipitation.mm\n  ) %>% \n  janitor::clean_names() \n\n\n#\nK.vec = 2*c(2:8)+1; m = length(vancouver_precip$day)\nCVfit = matrix(0,  nrow=m, ncol=length(K.vec))\ny <- vancouver_precip$precipitation_mm\nt.day <- vancouver_precip$day_year\n\n\nfbasis=create.fourier.basis(rangeval = c(1,365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\nfor(j in 1:m){\n  \n  Y.star = y[-j]\n  \n  # fit using Fourier basis and K basis functions\n  index=0\n  for (K in K.vec){\n    index=index+1\n    Xbasis=bvals[, 1:K];\n    Xbasis.j =  Xbasis[-j, ]; \n    lm.fit = lm(Y.star~0+Xbasis.j); Xbasis.coeff = lm.fit$coefficients\n    y.fit = Xbasis%*%Xbasis.coeff\n    CVfit[j,index] = (y[j] - y.fit[j])^2\n  }\n}\n\nCV_L2 = apply(CVfit, 2, sum)\n\n\nplot_resid <- bind_cols(bases_number = K.vec,\n                        CV_L2 = CV_L2\n                        )\n\nplot_resid %>% \n  ggplot(aes(bases_number, CV_L2))+\n  geom_line()+\n  geom_point()+\n  labs(x=\"Numero de funções base\",\n       y=\"erro total da validação cruzada\",\n       title=\"K=13 com o menor valor da validação cruzada\")\n\n```\n\nAqui nos concentramos nas medições médias de precipitação realizadas em Vancouver. (Atividade em grupo) Tente este exercício com as medições realizadas em Quebec $(l = 10)$. Ainda escolheria $K = 13$ como o número ótimo de funções de base? E em relação a outros locais?\n\nVerificando para Quebec!\n\n```{r}\nquebec_precip <- precipitation %>% \n dplyr::select(value, dplyr::contains(\"Quebec\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_year = 1:nrow(precipitation)\n  ) %>% \n  rename(\n    precipitation_mm = Quebec.Precipitation.mm\n  ) %>% \n  janitor::clean_names() \n\n\n#\nK.vec = 2*c(2:8)+1; m = length(quebec_precip$day)\nCVfit = matrix(0,  nrow=m, ncol=length(K.vec))\ny <- quebec_precip$precipitation_mm\nt.day <- quebec_precip$day_year\n\n\nfbasis=create.fourier.basis(rangeval = c(1,365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\nfor(j in 1:m){\n  \n  Y.star = y[-j]\n  \n  # fit using Fourier basis and K basis functions\n  index=0\n  for (K in K.vec){\n    index=index+1\n    Xbasis=bvals[, 1:K];\n    Xbasis.j =  Xbasis[-j, ]; \n    lm.fit = lm(Y.star~0+Xbasis.j); Xbasis.coeff = lm.fit$coefficients\n    y.fit = Xbasis%*%Xbasis.coeff\n    CVfit[j,index] = (y[j] - y.fit[j])^2\n  }\n}\n\nCV_L2 = apply(CVfit, 2, sum)\n\n\nplot_resid <- bind_cols(bases_number = K.vec,\n                        CV_L2 = CV_L2\n)\n\nplot_resid %>% \n  ggplot(aes(bases_number, CV_L2))+\n  geom_line()+\n  geom_point()+\n  labs(x=\"Numero de funções base\",\n       y=\"erro total da validação cruzada\",\n       title=\"K=5 com o menor valor da validação cruzada\")\n```\n\nComo verificamos o número ideal de funções base para Quebec é igual a 5.\n\n```{r}\nquebec_precip %>% \n  ggplot(aes(day_year, precipitation_mm))+\n  geom_point()+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 5), se = FALSE)+\n  labs(x = \"dia\", y = \"precipitação mm\")\n```\n\n## 5 Como levar em consideração a suavidade na curva subjacente?\n\nSuavização com Penalidade de Rugosidade\n\nConforme discutido na palestra, uma maneira melhor de controlar o viés e a variância é definir a suavidade de uma função e controlá-la por meio do parâmetro de penalidade λ.\n\nPrimeiro, vamos analisar a curva suavizada para um parâmetro de penalidade específico. Aqui, novamente, usamos as medições de precipitação de Vancouver e construímos as funções de base b-spline. Observe a quantidade de funções de base que construímos! Sem a penalidade de rugosidade, o ajuste dos mínimos quadrados ordinários conecta cada uma das medições!\n\n```{r}\n# define domain, #knots, and #order to construct b-spline basis\nmonths <- row.names(CanadianWeather$dailyAv) %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nprecipitation <- CanadianWeather$dailyAv %>% \n  as_tibble() %>% \n dplyr::select(contains(c(\"Precipitation\"))) %>% \n  rownames_to_column() \n\nprecipitation <- left_join(months, precipitation, by = \"rowname\") %>% \n dplyr::select(-rowname) \n\nvancouver_precip <- precipitation %>% \ndplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_year = 1:nrow(precipitation)\n  ) %>% \n  rename(\n    precipitation_mm = Vancouver.Precipitation.mm\n  ) %>% \n  janitor::clean_names() \n\n#\nt.day <- vancouver_precip$day_year\ny <- vancouver_precip$precipitation_mm\n\ny.basis  <- create.bspline.basis(rangeval = c(1,365), nbasis = 365, norder=4)\n\nbvals = eval.basis(t.day, y.basis)\nXbasis =bvals; \n\n\nlm.fit = lm(y ~ 0 + Xbasis)   \n\nplot_df <- cbind(day_year = t.day, prec_mm = y ,fitted = lm.fit$fitted.values) %>% \n  as_tibble()\n\n#\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_line(color = \"red\")+\n  geom_point(color = \"blue\")+\n geom_line(aes(day_year, fitted), color = \"green\")+\n  labs(x=\"dia\",y=\"precipitação mm\", title=\"365 bases de Fourier\")\n```\n\nAgora vamos usar a penalidade de rugosidade λ e ver o seu efeito na suavidade do ajuste resultante.\n\n```{r}\nlambda <- 10^4\n```\n\n`int2Lfd(m)`: use isso para definir o termo de penalidade de derivada de ordem m\n\n`fdPar()`: define os parâmetros funcionais; neste caso, o termo de penalidade de segunda ordem da derivada e o parâmetro de suavização.\n\n`ybasis  <- create.bspline.basis(rangeval = c(1,365), nbasis = 365, norder=4)`\n\n```{r}\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\n```\n\n`smooth.basis()`:suaviza os dados usando a penalidade de rugosidade e o parâmetro de suavização especificados em `tD2fdPar`\n\n```{r}\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n```\n\nnames(tyfd) \\[1\\] \"fd\" \"df\" \"gcv\" \"beta\" \"SSE\" \"penmat\" \"y2cMap\"\\\n\"argvals\" \"y\"\n\n-   `fd` um objeto de dados funcionais contendo uma suavização dos dados.\n-   `df` uma medida de graus de liberdade da suavização.\n-   `gcv` o valor do critério de validação cruzada generalizado ou GCV.\n-   `beta` os coeficientes de regressão associados às variáveis covariáveis.\n-   `SSE` as somas dos quadrados do erro.\n-   `penmat`: a matriz de penalidade.\n-   `y2cMap` a matriz que mapeia os dados nos coeficientes: $\\left(\\Phi^T \\Phi + R\\right)^{-1} \\Phi^T$\n\n```{r}\nplot_df <- cbind(plot_df, smooth = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth), color = \"green\",linewidth = 2)+\n  labs(x=\"dia\", y=\"precipitação mm\", title = \"Vancouver (lambda=10000)\")\n```\n\nO ajuste resultante com o parâmetro de suavização $λ=104$ está bastante suave! (Atividade em grupo) Experimente valores diferentes de $λ$ $(λ=0,0001, λ=100, λ=108)$ e discuta!\n\n```{r}\nlambda <- 0.0001\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n\n\nplot_df <- cbind(plot_df, smooth2 = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth2), color = \"green\",linewidth = 2)\n```\n\n```{r}\nlambda <- 100\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n\n\nplot_df <- cbind(plot_df, smooth3 = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth3), color = \"green\",linewidth = 2)\n```\n\n```{r}\nlambda <- 10^8\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n\n\nplot_df <- cbind(plot_df, smooth4 = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth4), color = \"green\",linewidth = 2)\n```\n\nExistem várias maneiras de selecionar o $λ$ ótimo; por exemplo, validação cruzada (atividade extraclasse), validação cruzada generalizada (GCV), estimação da máxima verossimilhança restrita (ReML) e assim por diante. Aqui ilustramos a seleção do parâmetro de suavização usando o escore GCV. O escore GCV é definido como\n\n$$\nGCV(\\lambda) = \\frac{m}{m-df(\\lambda)} \\times \\frac{SSE}{m-df(\\lambda)}\n$$\n\nonde:\n\nm é o número total de observações nos dados, $df(\\lambda)$ é a medida de graus de liberdade da suavização para o parâmetro de $suavização \\lambda$, e SSE é a soma dos quadrados do erro.\n\nGeralmente, o GCV resulta em um ajuste mais suave do que o CV porque a qualidade do ajuste (medida pela SSE) é penalizada tanto pelos graus de liberdade df(λ) quanto pelo parâmetro de suavização λ.\n\nO código a seguir usa o GCV para selecionar o λ ótimo, considerando 71 valores candidatos.\n\n```{r}\nlogl=seq(-5, 12, len=71)  \n#range(exp(logl))\n\ngcv = rep(0,71)\n\nfor(i in c(1:length(logl))){\n  lambda=exp(logl[i])\n  \n  tD2fdPar = fdPar(y.basis,Lfdobj=int2Lfd(2),lambda=lambda)\n  tyfd = smooth.basis(t.day,y,tD2fdPar)\n  \n  gcv[i] = tyfd$gcv\n}\n\n# PLOT GCV of FIT versus log lambda\n\ngcv %>% \n  as_tibble_col() %>% \n  mutate(\n    logl = logl\n  ) %>% \n  ggplot(aes(logl, value))+\n  geom_line()+\n  labs(x=\"log lambda\", y=\"GCV\", title = \"GCV(log.lambda)\")\n```\n\nO parâmetro de suavização ótimo selecionado usando o GCV é 992.2747156 e o ajuste resultante é apresentado abaixo.\n\n```{r}\nindex.logl.opt = which(gcv==min(gcv))\nlambda.opt = exp(logl[index.logl.opt])\n\ntD2fdPar = fdPar(y.basis,Lfdobj=int2Lfd(2),lambda=lambda.opt)\ntyfd = smooth.basis(t.day,y,tD2fdPar)\n\n\nplot_df <- cbind(day_year = t.day, prec_mm = y ,fitted = lm.fit$fitted.values) %>% \n  as_tibble()\n\nplot_df <- cbind(plot_df, best_smooth = tyfd$fd$coefs[,1]) %>% \n  as_tibble()\n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point()+\n  geom_line(aes(day_year, best_smooth), color= \"green\", linewidth = 2)+\n  labs(x = \"dai\", y=\"precipitação mm\", title = \"parâmetro de suavização ótimo = 992\")\n```\n\nOutras funções de suavização disponíveis no R\n\n-   A função `gam` no pacote `mgcv` possui diversas funções de base e métodos de seleção.\n    -   para o parâmetro de suavização. É flexível e útil!\n    -   Vamos utilizar esta função nos capítulos seguintes!\n    -   Exemplo (atividade extraclasse):\n\n```{r}\nlibrary(mgcv)\n\nfit = gam(y ~ s(t.day, k = 30, bs = \"cr\"), method = 'REML')\n\nfit %>% \nbroom::augment() %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, .fitted), color=\"green\", linewidth = 1.5)+\n  ggtitle(\"usando a função gam (REML)\")\n```\n\n-   Função \"ksmooth\" (suavização por regressão do núcleo)\n    -   Exemplo (atividade extraclasse): experimente um núcleo gaussiano (\"normal\") e diferentes larguras de banda (0.1, 10, 30).\n\n```{r}\nfit2 = ksmooth(t.day, y, kernel = c(\"box\"), bandwidth = 10)\n\nfit %>% \n broom::augment() %>% \n  mutate(\n    ksmooth_box = fit2$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_box), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (box)\")\n\n#\n#\n# kernel (“normal”) - bandwidth = 10\n\nfit3 = ksmooth(t.day, y, kernel = c(\"normal\"), bandwidth = 10)\n\nfit %>% \nbroom::augment() %>% \n  mutate(\n    ksmooth_normal = fit3$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_normal), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (normal|10)\")\n\n#\n#\n# kernel (“normal”) - bandwidth = 0.1\n\nfit4 = ksmooth(t.day, y, kernel = c(\"normal\"), bandwidth = 0.1)\n\nfit %>% \nbroom::augment() %>% \n  mutate(\n    ksmooth_normal = fit4$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_normal), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (normal|0.1)\")\n\n\n#\n# kernel (“normal”) - bandwidth = 0.1\n\nfit5 = ksmooth(t.day, y, kernel = c(\"normal\"), bandwidth = 30)\n\nfit %>% \nbroom::augment() %>% \n  mutate(\n    ksmooth_normal = fit5$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_normal), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (normal|30)\")\n```\n\n# 5 Resumo\n\n-   Explorou diversas funções de base.\n-   Realizou ajustes de curvas suaves utilizando o método dos mínimos quadrados ordinários (OLS).\n-   Discutiu o trade-off entre viés e variância, assim como a seleção do número de funções de base através da validação cruzada.\n-   Também realizou ajustes de curvas suaves utilizando o critério de erro quadrático penalizado.\n-   Por fim, foram discutidos diversos métodos para selecionar o parâmetro de suavização ótimo (λ).\n\nAtividades em Grupo / Atividades Extraclasse:\n\n1)  Página 2: Experimente diferentes números de funções de base e faça ajustes utilizando o método dos mínimos quadrados ordinários (atividade em grupo).\n2)  Página 3: Exercício de validação cruzada com medidas de precipitação transformadas em logaritmo obtidas em Quebec (atividade em grupo).\n3)  Página 4: Experimente as funções gam e ksmooth, especialmente a função gam, pois a utilizaremos nos capítulos seguintes! (atividade extraclasse).\n","srcMarkdownNoYaml":"\n\n```{r, echo=FALSE}\nknitr::opts_chunk$set(fig.align = 'center', out.width=\"100%\", fig.retina = 2)\n\npacman::p_load(tidyverse, lme4, mgcv, refund, face, fda, rgl, fields, refund.shiny, janitor)\n```\n\n# Modelagem de dados funcionais com expansões de base predefinida {#secao-2}\n\n## Tópicos dia 2:\n\n-   Construir diferentes funções de base em R\n\n-   Criar dados funcionais\n\n-   Regressão linear em funções de base (OLS)\n\n-   Como escolher o número de funções de base?\n\n-   Como explicar a suavidade na curva subjacente?\n\n    -   métodos do kernel\n    -   Suavização penalizada e seleção do parâmetro de suavização\n\n\\[Os Código são cortesia de Giles Hooker\\]\n\n## 1 Várias funções base:\n\nAs funções base, também conhecidas como funções de base, são utilizadas em análise estatística e modelagem para descrever ou aproximar relações complexas entre variáveis. Elas são usadas como componentes de modelos estatísticos e permitem representar de forma flexível e adequada diferentes padrões de dados.\n\nAs funções base são frequentemente aplicadas em análise de regressão, onde o objetivo é encontrar uma função que relacione uma variável dependente a uma ou mais variáveis independentes. Elas formam uma base para representar o comportamento geral dos dados e permitem expressar as relações entre as variáveis de forma mais simples e interpretável.\n\nExistem diferentes tipos de funções base, sendo as mais comuns:\n\n-   Funções polinomiais: São funções base construídas a partir de polinômios. Geralmente são utilizadas funções polinomiais de grau baixo, como polinômios de primeira e segunda ordem, para ajustar curvas lineares e quadráticas, respectivamente.\n\n-   Funções splines: As funções splines dividem o domínio de interesse em segmentos menores e utilizam polinômios de grau baixo em cada segmento para modelar os dados. Isso permite uma flexibilidade maior na representação de padrões complexos e não lineares.\n\n-   Funções de onda: São funções que se repetem ao longo de um domínio e podem ser usadas para modelar fenômenos periódicos. Exemplos comuns são as funções seno e cosseno.\n\n-   Funções de base radial: São funções que dependem da distância entre pontos de dados e um centro definido. Essas funções são frequentemente utilizadas em problemas de interpolação ou para modelar dados com padrões radiais.\n\nAo escolher as funções base adequadas, é possível capturar diferentes características dos dados e ajustar modelos que se ajustem melhor aos padrões observados. A seleção correta das funções base é um aspecto importante na modelagem estatística, e depende do conhecimento do pesquisador sobre o problema em questão, bem como das características dos dados disponíveis.\n\n### 1.1 Biblioteca fda\n\nA biblioteca fda (Functional Data Analysis) é um pacote em R que fornece funcionalidades para análise de dados funcionais. A análise de dados funcionais é uma área da estatística que lida com dados observados como funções contínuas ao longo de uma dimensão, como séries temporais, curvas suaves ou imagens médicas.\n\nO fda permite a manipulação, visualização, modelagem e análise de dados funcionais de maneira eficiente. Alguns recursos e funcionalidades principais do fda incluem:\n\n-   Representação de dados funcionais: O pacote oferece estruturas de dados adequadas para representar e armazenar dados funcionais, como objetos fd (functional data) e fdata (functional data array).\n\n-   Visualização de dados funcionais: O fda inclui funções para plotagem e visualização de dados funcionais, permitindo a criação de gráficos de séries temporais, curvas suaves e outras representações visuais adequadas para dados funcionais.\n\n-   Análise exploratória: O pacote fornece métodos estatísticos para análise exploratória de dados funcionais, incluindo medidas descritivas, como média, mediana e desvio padrão funcional, além de ferramentas para análise de variabilidade e análise de componentes principais funcionais.\n\n-   Modelagem e ajuste de dados funcionais: O fda oferece métodos para modelar dados funcionais, incluindo regressão funcional, análise de covariância funcional e análise de séries temporais funcionais. Isso permite ajustar modelos estatísticos apropriados aos dados funcionais.\n\n-   Alinhamento e registro de dados funcionais: O pacote inclui funções para alinhar e registrar dados funcionais, que são úteis quando se deseja comparar ou combinar diferentes curvas ou séries temporais funcionais.\n\nA biblioteca fda é uma ferramenta poderosa para análise de dados funcionais e pode ser usada em uma variedade de aplicações, como medicina, economia, engenharia e muitas outras áreas em que os dados são naturalmente representados como funções contínuas.\n\n### 1.2 Bases Monomiais\n\nA função base monomial, do pacote fda, requer o domínio e o número da base. Por exemplo, a base monomial com K=6 funções de base definidas no intervalo \\[0,1\\] pode ser construída da seguinte forma.\n\n```{r}\nbbasis_obj = create.monomial.basis(rangeval=c(0,1), nbasis = 6)\n```\n\nIsso retornará uma saída como \"funções\". Para avaliar as bases criadas, em uma grade de s pontos, podemos:\n\n```{r}\nx <- seq(0,1,length.out=100) # grade de pontos\n\nbbasisevals <- eval.basis(x, bbasis_obj) # avaliando as bases na grade de pontos\n```\n\nPara visualizar as bases monomiais:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbbasisevals1 <- bbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,bbasisevals1, by = \"rowname\")\n\n\nbasis_plot %>%\n    pivot_longer(\n    cols = starts_with(\"monomial\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n    ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  labs(x = \"X\", y = \"fns bases\", title = \"Bases monomiais com k=6\")\n```\n\n### 1.3 Bases de Fourier\n\nA análise de Fourier requer que sejam definidos o domínio, o período de oscilação e o número de funções de base.\n\n```{r}\nx <- seq(0,1,length.out=100)\n\nfbasis_obj <- create.fourier.basis(rangeval=c(0,1), \n                                 nbasis=65, period = 1)\n\nfbasisevals <- eval.basis(x, fbasis_obj)\n```\n\nPara visualizar as bases de Fourier:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nfbasisevals1 <- fbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,fbasisevals1, by = \"rowname\")\n\n# plotando as bases de fourier\nbasis_plot %>%\n dplyr::select(2:5) %>% # escolhendo o número de bases no plot - 2:5 três bases\npivot_longer(\n    cols = starts_with(c(\"sin\",\"co\")),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  labs(x = \"X\", y = \"fns bases\", title = \"Três primeiras bases de Fourie\")\n```\n\n### 1.4 Bases B-Spline\n\nA base B-spline requer o domínio, as funções de base numérica e o grau.\n\n```{r}\nx <- seq(0,1,length.out=100)\n\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                    nbasis=10, norder=4)\n\nbsbasisevals <- eval.basis(x, bsbasis_obj)\n\n\n```\n\nPara visualizar as bases de B-spline:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbsbasisevals1 <- bsbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,bsbasisevals1, by = \"rowname\")\n\n# plotando B-Spline basis\nbasis_plot %>%\ndplyr::select(2:12) %>% \n  pivot_longer(\n    cols = starts_with(\"bspl\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  labs(x = \"X\", y = \"fns bases\", title = \"B-spline cúbica com k=10\")+\n  theme(\n    legend.position = \"none\"\n  )\n \n```\n\nTestando diferentes valores de `nbasis` e/ou `norder`.\n\n```{r}\n# norder =2\nx <- seq(0,1,length.out=100)\n\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                    nbasis=10, norder=2)\n\nbsbasisevals <- eval.basis(x, bsbasis_obj)\n\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbsbasisevals1 <- bsbasisevals %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nbasis_plot <- left_join(x1,bsbasisevals1, by = \"rowname\")\n\n# plotando B-Spline basis\nbasis_plot %>%\ndplyr::select(2:12) %>% \n  pivot_longer(\n    cols = starts_with(\"bspl\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )+\n  labs(x = \"X\", y = \"fns bases\", title = \"B-spline linear com k=10\")\n```\n\n### 1.5 Outras bases\n\nO pacote fda também oferece a possibilidade de construir outros tipos de bases. Para visualizar a lista de bases disponíveis, você pode digitar ?create.+\"tab\".\n\n## 2 O objeto dados funcionais (FD) do pacote fda\n\nDefinido por uma base de funções e um vetor de coeficientes aleatórios correspondentes, a função fd desempenha o papel de construtor de objetos de dados funcionais.\n\n```{r}\nnb <- 10\ncoef <- rnorm(nb)\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                  nbasis=nb, norder=4)\n\nfd_obj <- fd(coef, bsbasis_obj)\nx <- seq(0,1,length.out = 100)\nfd_eval <- eval.fd(x, fd_obj)\n```\n\nPara visualizar as bases de aleatórias:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n#\nfd_eval1 <- fd_eval %>% \n  as_tibble() %>% \n  rownames_to_column()\n#\nbasis_plot <- left_join(x1,fd_eval1, by = \"rowname\")\n#\n# plotando B-Spline basis\nbasis_plot %>%\n   pivot_longer(\n    cols = starts_with(\"reps\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )+\n  labs(x = \"X\", y = \"fns bases\", title = \"Função aleatória usando B-spline\")\n```\n\nTente executar o código acima várias vezes. Tente também executar o código com um número diferente de funções base, por exemplo nb \\<- 5, nb \\<- 15, nb \\<- 30.\n\nPara gerar (n = 20) múltiplas funções aleatórias você pode criar uma matriz de coeficientes aleatórios com dimensão de #bases por n; por exemplo.\n\n```{r}\nn <- 20 ; nb <- 10\ncoef = matrix(rnorm(n*nb),nb,n)\n# dim(coefs)   # [1]  10 20\n\nbsbasis_obj <- create.bspline.basis(rangeval=c(0,1),\n                                    nbasis=nb, norder=4)\nfd_obj <- fd(coef, bsbasis_obj)\nx <- seq(0,1,length.out = 100)\nfd_eval <- eval.fd(x, fd_obj)\n```\n\nPara visualizar as funções aleatórias:\n\n```{r}\nx1 <- x %>% \n  as_tibble() %>% \n  rownames_to_column()\n\n\nfd_eval1 <- fd_eval %>% \n  as_tibble() %>% \n  rownames_to_column()\n\n\nbasis_plot <- left_join(x1,fd_eval1, by = \"rowname\")\n\n\nbasis_plot %>%\n  # select(2:12) %>% # escolhendo o número de bases no plot - 2:5 três bases\n  pivot_longer(\n    cols = starts_with(\"reps\"),\n    names_to = \"degree\",\n    values_to = \"values\") %>%\n  group_by(value) %>% \n  ggplot(aes(value, values, group = degree, color = degree))+\n  geom_line()+\n  theme(\n    legend.position = \"none\"\n  )+\n  labs(x = \"X\", y = \"fns bases\", title = \"20 Funções aleatórias usando B-spline\")\n```\n\nAlgumas outras funções úteis do pacote fda:\n\n1)  `deriv.fd`: fornece a derivada de um objeto fd (o valor retornado também é um objeto fd); por exemplo. tente `drfd_obj <- deriv.fd(fd_obj, 1)`; `eval.fd(drfd_obj, x)`.\n\n2)  podemos fazer aritmética com os objetos fd; por exemplo. `eval.fd(fd_obj[1]+fd_obj[2], x)`\n\n3)  operações estatísticas; por exemplo. `mean(fd_obj)` ou `std.fd(fd_obj)`\n\n## 3 Regressão linear em funções de base (OLS)\n\nAqui, tentaremos usar diferentes funções básicas para suavizar os dados meteorológicos canadenses, que estão disponíveis no pacote fda.\n\n(Ilustrado com base de Fourier)\n\nVamos nos concentrar na precipitação média diária de Vancouver (transformação log), representada por apenas uma das curvas observadas.\n\n```{r}\n\ndata(\"CanadianWeather\")\n\n#str(CanadianWeather)\n\n#view(CanadianWeather$dailyAv)\n\nmonths <- row.names(CanadianWeather$dailyAv) %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nprecipitation_log <- CanadianWeather$dailyAv %>% \n  as_tibble() %>% \n dplyr::select(contains(c(\"log\"))) %>% \n  rownames_to_column() \n\n\nprecipitation_log <- left_join(months, precipitation_log, by = \"rowname\") %>% \n dplyr::select(-rowname)\n\nprecipitation_log %>% \ndplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_month = as.numeric(day),\n    day_year = 1:nrow(precipitation_log)\n  ) %>% \n  ggplot(aes(day_year, Vancouver.log10precip))+\n  geom_point()+\n  geom_line()+\n  labs(x = \"dia\", y = \"precipitação-log\", title = \"log da precipitação média diária de vancouver\")\n```\n\nAgora vamos tentar suavizar os pontos observados usando a base de Fourier. Para usar a base de Fourier, precisamos definir o domínio, o período e o número da base.\n\n```{r}\nday <- 1:365\nrangval=range(day)\nperiod = 365 \n\nnbasis = 3 \nfbasis=create.fourier.basis(rangval, nbasis=nbasis, period=period)  \nbvals = eval.basis(day, fbasis)\nXbasis =bvals\n```\n\nVamos ajustar um modelo de regressão linear utilizando as funções de base criadas (OLS).\n\n```{r}\nlm.fit = lm(Vancouver.log10precip ~ 0 + Xbasis, data = precipitation_log) \n\n# Visualizando o modelo\n\nlm.fit %>%\n broom::augment() %>% \n  mutate(\n    day_year = 1:365\n  ) %>% \n  ggplot(aes(day_year, `Vancouver.log10precip`))+\n  geom_point()+\n  geom_line(aes(day_year, .fitted), color = \"red\", linewidth = 2, linetype = 1)+\n  labs(x = \"dia\", y = \"precipitação-log\", title = \"Fourier-nbasis = 3\")\n```\n\nCalculando a segunda derivada da curva ajustada.\n\n```{r}\nyfitfd = fd(lm.fit$coefficients,fbasis)  #obtain FD object\nyfit2D = eval.fd(day, yfitfd, 2) # evaluate the 2nd deriv. of the fit at day\n\nyfit2D %>% \n  bind_cols(day) %>%\n  ggplot(aes(`...2`, `...1` ))+\n  geom_line()+\n  theme_classic()+\n  labs(x = \"dia\", y = \"2D precipitação-log\", title = glue::glue(\"Média dos quadrados da 2D log-precp. = \", \n               round(mean(yfit2D^2),2)))\n```\n\nAgora tente o código com nbasis = 13, nbasis = 27 e nbasis = 365. Qual é o efeito de usar diferentes números de bases?\n\n## 4 Como determinar o número de funções de base?\n\nEstudo de simulação (compensação de viés-variância)\n\nPara saber mais sobre o estudo de simulação, [aqui](https://www4.stat.ncsu.edu/~davidian/st810a/simulation_handout.pdf) estão os slides preparados pelo Dr. Davidian.\n\nO exercício de simulação a seguir ilustra a compensação de viés-variância. Vamos nos concentrar em observar o efeito de diferentes escolhas de número de funções de base no viés, variância e erro quadrático médio (MSE).\n\nO viés e a variância do estimador $\\hat{X}(t)$ são dados por:\n\n$$\n\\text{Bias}(\\hat{X}(t)) = E\\{\\hat{X}(t)\\} - X(t), e\n$$\n\n$$\n\\text{Var}(\\hat{X}(t)) =\\mathbb{E}\\left[ \\left( \\hat{X}(t) - \\mathbb{E}\\left[ \\hat{X}(t) \\right] \\right)^2 \\right],\n$$\n\nrespectivamente. Para t fixo, o MSE é definido como:\n\n$$\n\\text{MSE}\\left\\{\\hat{X}(t)\\right\\} = \\mathbb{E}\\left[ \\left( \\hat{X}(t) - \\mathbb{E}\\left[X(t) \\right] \\right)^2 \\right] = \\text{Bias}^2\\{\\hat{X}(t)\\} + \\text{Var}\\{\\hat{X}(t)\\}\n$$\n\nPara uma curva $Y(\\cdot)$ gostaríamos de selecionar o número de funções de base para minimizar o erro quadrado médio integrado, $\\int TMSE\\{\\hat{X}(t)\\} dt.$\n\nPodemos estudar essas estatísticas por meio de simulação. Neste caso, iremos gerar conjuntos de dados simulados que imitam as medições de precipitação realizadas em Vancouver $(l=26)$.\n\nA seguir está um breve esboço do experimento de simulação:\n\n1)  Suavize as medições de precipitação de Vancouver, $Y(t_j)$, usando B-spline e obtenha\n\n-   a curva ajustada, $\\hat{X}_0(\\cdot)$.\n\n-   Os resíduos, $\\epsilon_j = Y(t_j) - \\hat{X}_0(t_j)$.\n\n2)  Assuma que a curva ajustada, $\\hat{X}_0(\\cdot)$, é a \"verdadeira\" curva subjacente, $X(\\cdot)$.\n\n3)  Gere um conjunto de dados simulados adicionando resíduos, $epsilon^*_j$, reamostrados aleatoriamente à curva subjacente \"verdadeira\",$X(\\cdot)$; em outras palavras, obtenha $Y^*_j$ por meio da adição dos resíduos reamostrados à curva subjacente $Y^*_j = X(t_j) + \\epsilon^*_j$.\n\nRepita o Passo 3 para gerar muitos conjuntos de dados simulados!\n\nAjuste cada conjunto de dados simulados usando uma base de Fourier com K funções de base para várias escolhas de K.\n\nPara cada K, calcule o viés, a variância e o MSE.\n\nA seguir, passarei pelo código de simulação para um conjunto de dados simulado. Primeiro, definimos a resposta de interesse.\n\n```{r}\ndata(\"CanadianWeather\")\n\n#str(CanadianWeather)\n\n#view(CanadianWeather$dailyAv)\n\nmonths <- row.names(CanadianWeather$dailyAv) %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nprecipitation <- CanadianWeather$dailyAv %>% \n  as_tibble() %>% \n  dplyr::select(contains(c(\"Precipitation\"))) %>% \n  rownames_to_column() \n\n\nprecipitation <- left_join(months, precipitation, by = \"rowname\") %>% \n  dplyr::select(-rowname)\n\n```\n\nPlotando os dados de precipitação\n\n```{r}\nvancouver_precip <- precipitation %>% \n     dplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n      separate_wider_position(value,c(month = 3,day=2)) %>% \n      mutate(\n         day_year = 1:nrow(precipitation)\n      ) %>% \n      rename(\n        precipitation_mm = Vancouver.Precipitation.mm\n      ) %>% \n      janitor::clean_names() \n      \nvancouver_precip %>% \n  ggplot(aes(day_year, precipitation_mm))+\n  geom_point()\n```\n\nEm seguida, construímos um estimador suave utilizando funções de base B-spline cúbicas penalizadas (Passo 1). Vamos considerar a linha preta como a 'verdade'. Nesse caso, utilizamos a função `gam` (do pacote `mgcv`) para a suavização, a qual será explicada em breve.\n\n```{r}\n\nlibrary(mgcv)\nday <- 1:365\nfit <- gam(vancouver_precip$precipitation_mm ~s(day, k = 10, bs = \"cr\"), method=\"REML\")\n```\n\nPor simplicidade vamos plotar essa curva ajustada usando o pacote `ggplot2`.\n\n```{r}\nvancouver_precip %>% \n  ggplot(aes(day_year, precipitation_mm))+\n  geom_point()+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 10), se = FALSE)\n```\n\nPara gerar um conjunto de dados simulados (Passos 2-3)\n\nVerificando os resíduos do modelo gerado\n\n```{r}\nfit %>% \nbroom::augment() %>% \n  ggplot(aes(.resid))+\n  geom_histogram(bins = 15)+\n  theme_light()\n```\n\n```{r}\nplot_df <- fit %>% \n      broom::augment() %>%\n        as_tibble() %>% \n        janitor::clean_names()\n\nset.seed(420)\nplot_df %>% \n  mutate(\n    Eps.star = sample(resid, size = 365, replace = TRUE),\n    Y.star = fitted + Eps.star\n  ) %>% \n  ggplot(aes(day, Y.star))+\n  geom_point(alpha = 0.7)+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 10), se = FALSE,linewidth = 2)+\n  geom_point(aes(day,vancouver_precip_precipitation_mm), color = \"red\", alpha = 0.7)+\n  geom_point(aes(day,fitted), color = \"green\")\n\n\n# salvando os dados simulados\nsimulated_precip<- plot_df %>% \n          mutate(\n            Eps.star = sample(resid, size = 365, replace = TRUE),\n            Y.star = fitted + Eps.star\n          )\n```\n\nOs pontos em vermelho são os dados originais, em preto os simulados. A linha em azul é o modelo ajustado aos dados ariginais e a linha em verda o modelo ajustado aos dados simulados.\n\nUma vez que geramos o conjunto de dados simulados, faremos a suavização utilizando a função de base de Fourier com K funções de base, para várias escolhas de K. Aqui consideramos 7 valores diferentes; $K = 2 \\cdot \\text{c}(2:8) + 1$\n\n```{r, warning=FALSE}\nK.vec = 2*c(2:8)+1;    # we consider 7 different values of k.\n# K.vec\nt.day <- 1:365\nm <- length(plot_df$resid)\n\nfbasis=create.fourier.basis(rangeval = c(1, 365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\n\nXfit = array(0, c(m, length(K.vec)))\nindex=0\nfor (K in K.vec){\n  index=index+1\n  Xbasis = bvals[, 1:K]\n  lm.fit = lm(Y.star~0+Xbasis, data = simulated_precip)\n  Xfit[,index] = as.vector(lm.fit$fitted.values)\n}\n\n\nXfit_df <- Xfit %>% \n  as_tibble() %>% \n  rename(\n    model_5 = V1,\n    model_7 = V2,\n    model_9 = V3,\n    model_11 = V4,\n    model_13 = V5,\n    model_15 = V6,\n    model_17 = V7\n  ) %>% \n  mutate(\n    day = 1:365\n  )\n\n\nmodels_plot <- left_join(simulated_precip, Xfit_df, by = \"day\") \n\nmodels_plot %>% \n dplyr::select(day,Y.star,vancouver_precip_precipitation_mm,contains(\"model\")) %>% \n  pivot_longer(cols = contains(\"model\")) %>% \n  group_by(day) %>% \n  ggplot(aes(day,value, group = name, color = name))+\n  geom_line(linewidth = 1.5)+\n  geom_point(aes(day, Y.star), color = \"blue\", alpha = 0.7)+\n  geom_point(aes(day, vancouver_precip_precipitation_mm), color = \"red\", alpha = 0.7)\n\n```\n\nAgora, realizamos os passos acima para B=100 conjuntos de dados e calculamos o viés, a variância, o MSE (Erro Quadrático Médio) e o MSE integrado.\n\n```{r}\nK.vec = 2*c(2:8)+1; \nB=100 #B=10000\nm = length(simulated_precip$resid)\nXfit = array(0, c(B, m, length(K.vec)))\nt.day <- simulated_precip$day\n\nfbasis=create.fourier.basis(rangeval = c(1,365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\n# ----\n\nset.seed0=1234\nfor(b in 1:B){#b=1\n  set.seed(set.seed0+b)\n\n  simulated_precip <- plot_df %>% \n      mutate( \n        Eps.star = sample(resid, size = 365, replace = TRUE),\n        Y.star = fitted + Eps.star\n        )\n  \n  # fit using Fourier basis and K basis functions\n  index=0\n  for (k in K.vec){\n    index=index+1\n    Xbasis = bvals[, 1:k]\n    lm.fit = lm(Y.star~0+Xbasis, data = simulated_precip)\n    Xfit[b,,index] = as.vector(lm.fit$fitted.values)\n  }\n}\n\n\nMean.Est = apply(Xfit, c(2,3), mean)\nMean.Est2 = apply(Xfit, c(2,3), function(x) mean(x^2))\n\nXtrue <- simulated_precip$fitted\n\nBias = apply(Mean.Est, 2, function(x) Xtrue-x)\nVar = Mean.Est2 - (Mean.Est)^2\nMse= Bias^2+Var\n\nMean_Bias2_L2 = apply(Bias^2, 2, mean) \nVar_L2 = apply(Var, 2, mean) \nMSE_L2 = apply(Mse, 2, mean)\n\nbases_resid<- bind_cols(bases_number = K.vec,\n          mean_basis2 = Mean_Bias2_L2,\n          var_L2 = Var_L2,\n          MSE_L2 = MSE_L2)\n\nbases_resid %>% \n  pivot_longer(cols = 2:4) %>% \n  group_by(bases_number) %>% \n  ggplot(aes(bases_number, value,group = name, color = name))+\n  geom_line()+\n  geom_point()+\n  labs(x = \"número de funções de base\", y = \"erro quadrático total\")\n```\n\nCross-validation (Validação Cruzada)\n\nUma maneira de escolher o número de funções de base é a validação cruzada.\n\n\\[trecho dos apontamentos de aula :\\]\n\n-   Deixe de fora uma observação $(t_j, Y_j)$.\n-   Ajuste os dados restantes e obtenha $\\hat{X}_j(t_j)$ para várias escolhas de $K$.\n-   Escolha $K$ que minimize o escore de validação cruzada, definido como:\n\n$$CV(X) = \\sum_{j=1}^{m} (Y_j - \\hat{X}_j(t_j))^2$$\n\nEssas são as mesmas medições\n\n```{r}\nvancouver_precip <- precipitation %>% \ndplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_year = 1:nrow(precipitation)\n  ) %>% \n  rename(\n    precipitation_mm = Vancouver.Precipitation.mm\n  ) %>% \n  janitor::clean_names() \n\n\n#\nK.vec = 2*c(2:8)+1; m = length(vancouver_precip$day)\nCVfit = matrix(0,  nrow=m, ncol=length(K.vec))\ny <- vancouver_precip$precipitation_mm\nt.day <- vancouver_precip$day_year\n\n\nfbasis=create.fourier.basis(rangeval = c(1,365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\nfor(j in 1:m){\n  \n  Y.star = y[-j]\n  \n  # fit using Fourier basis and K basis functions\n  index=0\n  for (K in K.vec){\n    index=index+1\n    Xbasis=bvals[, 1:K];\n    Xbasis.j =  Xbasis[-j, ]; \n    lm.fit = lm(Y.star~0+Xbasis.j); Xbasis.coeff = lm.fit$coefficients\n    y.fit = Xbasis%*%Xbasis.coeff\n    CVfit[j,index] = (y[j] - y.fit[j])^2\n  }\n}\n\nCV_L2 = apply(CVfit, 2, sum)\n\n\nplot_resid <- bind_cols(bases_number = K.vec,\n                        CV_L2 = CV_L2\n                        )\n\nplot_resid %>% \n  ggplot(aes(bases_number, CV_L2))+\n  geom_line()+\n  geom_point()+\n  labs(x=\"Numero de funções base\",\n       y=\"erro total da validação cruzada\",\n       title=\"K=13 com o menor valor da validação cruzada\")\n\n```\n\nAqui nos concentramos nas medições médias de precipitação realizadas em Vancouver. (Atividade em grupo) Tente este exercício com as medições realizadas em Quebec $(l = 10)$. Ainda escolheria $K = 13$ como o número ótimo de funções de base? E em relação a outros locais?\n\nVerificando para Quebec!\n\n```{r}\nquebec_precip <- precipitation %>% \n dplyr::select(value, dplyr::contains(\"Quebec\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_year = 1:nrow(precipitation)\n  ) %>% \n  rename(\n    precipitation_mm = Quebec.Precipitation.mm\n  ) %>% \n  janitor::clean_names() \n\n\n#\nK.vec = 2*c(2:8)+1; m = length(quebec_precip$day)\nCVfit = matrix(0,  nrow=m, ncol=length(K.vec))\ny <- quebec_precip$precipitation_mm\nt.day <- quebec_precip$day_year\n\n\nfbasis=create.fourier.basis(rangeval = c(1,365), nbasis=max(K.vec), period=365)\nbvals = eval.basis(t.day,fbasis)\n\nfor(j in 1:m){\n  \n  Y.star = y[-j]\n  \n  # fit using Fourier basis and K basis functions\n  index=0\n  for (K in K.vec){\n    index=index+1\n    Xbasis=bvals[, 1:K];\n    Xbasis.j =  Xbasis[-j, ]; \n    lm.fit = lm(Y.star~0+Xbasis.j); Xbasis.coeff = lm.fit$coefficients\n    y.fit = Xbasis%*%Xbasis.coeff\n    CVfit[j,index] = (y[j] - y.fit[j])^2\n  }\n}\n\nCV_L2 = apply(CVfit, 2, sum)\n\n\nplot_resid <- bind_cols(bases_number = K.vec,\n                        CV_L2 = CV_L2\n)\n\nplot_resid %>% \n  ggplot(aes(bases_number, CV_L2))+\n  geom_line()+\n  geom_point()+\n  labs(x=\"Numero de funções base\",\n       y=\"erro total da validação cruzada\",\n       title=\"K=5 com o menor valor da validação cruzada\")\n```\n\nComo verificamos o número ideal de funções base para Quebec é igual a 5.\n\n```{r}\nquebec_precip %>% \n  ggplot(aes(day_year, precipitation_mm))+\n  geom_point()+\n  geom_smooth(method = lm, formula = y ~ splines::bs(x, 5), se = FALSE)+\n  labs(x = \"dia\", y = \"precipitação mm\")\n```\n\n## 5 Como levar em consideração a suavidade na curva subjacente?\n\nSuavização com Penalidade de Rugosidade\n\nConforme discutido na palestra, uma maneira melhor de controlar o viés e a variância é definir a suavidade de uma função e controlá-la por meio do parâmetro de penalidade λ.\n\nPrimeiro, vamos analisar a curva suavizada para um parâmetro de penalidade específico. Aqui, novamente, usamos as medições de precipitação de Vancouver e construímos as funções de base b-spline. Observe a quantidade de funções de base que construímos! Sem a penalidade de rugosidade, o ajuste dos mínimos quadrados ordinários conecta cada uma das medições!\n\n```{r}\n# define domain, #knots, and #order to construct b-spline basis\nmonths <- row.names(CanadianWeather$dailyAv) %>% \n  as_tibble() %>% \n  rownames_to_column()\n\nprecipitation <- CanadianWeather$dailyAv %>% \n  as_tibble() %>% \n dplyr::select(contains(c(\"Precipitation\"))) %>% \n  rownames_to_column() \n\nprecipitation <- left_join(months, precipitation, by = \"rowname\") %>% \n dplyr::select(-rowname) \n\nvancouver_precip <- precipitation %>% \ndplyr::select(value, dplyr::contains(\"Vancouver\")) %>% \n  separate_wider_position(value,c(month = 3,day=2)) %>% \n  mutate(\n    day_year = 1:nrow(precipitation)\n  ) %>% \n  rename(\n    precipitation_mm = Vancouver.Precipitation.mm\n  ) %>% \n  janitor::clean_names() \n\n#\nt.day <- vancouver_precip$day_year\ny <- vancouver_precip$precipitation_mm\n\ny.basis  <- create.bspline.basis(rangeval = c(1,365), nbasis = 365, norder=4)\n\nbvals = eval.basis(t.day, y.basis)\nXbasis =bvals; \n\n\nlm.fit = lm(y ~ 0 + Xbasis)   \n\nplot_df <- cbind(day_year = t.day, prec_mm = y ,fitted = lm.fit$fitted.values) %>% \n  as_tibble()\n\n#\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_line(color = \"red\")+\n  geom_point(color = \"blue\")+\n geom_line(aes(day_year, fitted), color = \"green\")+\n  labs(x=\"dia\",y=\"precipitação mm\", title=\"365 bases de Fourier\")\n```\n\nAgora vamos usar a penalidade de rugosidade λ e ver o seu efeito na suavidade do ajuste resultante.\n\n```{r}\nlambda <- 10^4\n```\n\n`int2Lfd(m)`: use isso para definir o termo de penalidade de derivada de ordem m\n\n`fdPar()`: define os parâmetros funcionais; neste caso, o termo de penalidade de segunda ordem da derivada e o parâmetro de suavização.\n\n`ybasis  <- create.bspline.basis(rangeval = c(1,365), nbasis = 365, norder=4)`\n\n```{r}\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\n```\n\n`smooth.basis()`:suaviza os dados usando a penalidade de rugosidade e o parâmetro de suavização especificados em `tD2fdPar`\n\n```{r}\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n```\n\nnames(tyfd) \\[1\\] \"fd\" \"df\" \"gcv\" \"beta\" \"SSE\" \"penmat\" \"y2cMap\"\\\n\"argvals\" \"y\"\n\n-   `fd` um objeto de dados funcionais contendo uma suavização dos dados.\n-   `df` uma medida de graus de liberdade da suavização.\n-   `gcv` o valor do critério de validação cruzada generalizado ou GCV.\n-   `beta` os coeficientes de regressão associados às variáveis covariáveis.\n-   `SSE` as somas dos quadrados do erro.\n-   `penmat`: a matriz de penalidade.\n-   `y2cMap` a matriz que mapeia os dados nos coeficientes: $\\left(\\Phi^T \\Phi + R\\right)^{-1} \\Phi^T$\n\n```{r}\nplot_df <- cbind(plot_df, smooth = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth), color = \"green\",linewidth = 2)+\n  labs(x=\"dia\", y=\"precipitação mm\", title = \"Vancouver (lambda=10000)\")\n```\n\nO ajuste resultante com o parâmetro de suavização $λ=104$ está bastante suave! (Atividade em grupo) Experimente valores diferentes de $λ$ $(λ=0,0001, λ=100, λ=108)$ e discuta!\n\n```{r}\nlambda <- 0.0001\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n\n\nplot_df <- cbind(plot_df, smooth2 = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth2), color = \"green\",linewidth = 2)\n```\n\n```{r}\nlambda <- 100\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n\n\nplot_df <- cbind(plot_df, smooth3 = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth3), color = \"green\",linewidth = 2)\n```\n\n```{r}\nlambda <- 10^8\ntD2fdPar = fdPar(y.basis, Lfdobj=int2Lfd(2), lambda=lambda)\ntyfd = smooth.basis(t.day,y,tD2fdPar) \n\n\nplot_df <- cbind(plot_df, smooth4 = tyfd$fd$coefs[,1]) \n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point(color = \"red\")+\n  geom_line(aes(day_year, smooth4), color = \"green\",linewidth = 2)\n```\n\nExistem várias maneiras de selecionar o $λ$ ótimo; por exemplo, validação cruzada (atividade extraclasse), validação cruzada generalizada (GCV), estimação da máxima verossimilhança restrita (ReML) e assim por diante. Aqui ilustramos a seleção do parâmetro de suavização usando o escore GCV. O escore GCV é definido como\n\n$$\nGCV(\\lambda) = \\frac{m}{m-df(\\lambda)} \\times \\frac{SSE}{m-df(\\lambda)}\n$$\n\nonde:\n\nm é o número total de observações nos dados, $df(\\lambda)$ é a medida de graus de liberdade da suavização para o parâmetro de $suavização \\lambda$, e SSE é a soma dos quadrados do erro.\n\nGeralmente, o GCV resulta em um ajuste mais suave do que o CV porque a qualidade do ajuste (medida pela SSE) é penalizada tanto pelos graus de liberdade df(λ) quanto pelo parâmetro de suavização λ.\n\nO código a seguir usa o GCV para selecionar o λ ótimo, considerando 71 valores candidatos.\n\n```{r}\nlogl=seq(-5, 12, len=71)  \n#range(exp(logl))\n\ngcv = rep(0,71)\n\nfor(i in c(1:length(logl))){\n  lambda=exp(logl[i])\n  \n  tD2fdPar = fdPar(y.basis,Lfdobj=int2Lfd(2),lambda=lambda)\n  tyfd = smooth.basis(t.day,y,tD2fdPar)\n  \n  gcv[i] = tyfd$gcv\n}\n\n# PLOT GCV of FIT versus log lambda\n\ngcv %>% \n  as_tibble_col() %>% \n  mutate(\n    logl = logl\n  ) %>% \n  ggplot(aes(logl, value))+\n  geom_line()+\n  labs(x=\"log lambda\", y=\"GCV\", title = \"GCV(log.lambda)\")\n```\n\nO parâmetro de suavização ótimo selecionado usando o GCV é 992.2747156 e o ajuste resultante é apresentado abaixo.\n\n```{r}\nindex.logl.opt = which(gcv==min(gcv))\nlambda.opt = exp(logl[index.logl.opt])\n\ntD2fdPar = fdPar(y.basis,Lfdobj=int2Lfd(2),lambda=lambda.opt)\ntyfd = smooth.basis(t.day,y,tD2fdPar)\n\n\nplot_df <- cbind(day_year = t.day, prec_mm = y ,fitted = lm.fit$fitted.values) %>% \n  as_tibble()\n\nplot_df <- cbind(plot_df, best_smooth = tyfd$fd$coefs[,1]) %>% \n  as_tibble()\n\nplot_df %>% \n  ggplot(aes(day_year, prec_mm))+\n  geom_point()+\n  geom_line(aes(day_year, best_smooth), color= \"green\", linewidth = 2)+\n  labs(x = \"dai\", y=\"precipitação mm\", title = \"parâmetro de suavização ótimo = 992\")\n```\n\nOutras funções de suavização disponíveis no R\n\n-   A função `gam` no pacote `mgcv` possui diversas funções de base e métodos de seleção.\n    -   para o parâmetro de suavização. É flexível e útil!\n    -   Vamos utilizar esta função nos capítulos seguintes!\n    -   Exemplo (atividade extraclasse):\n\n```{r}\nlibrary(mgcv)\n\nfit = gam(y ~ s(t.day, k = 30, bs = \"cr\"), method = 'REML')\n\nfit %>% \nbroom::augment() %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, .fitted), color=\"green\", linewidth = 1.5)+\n  ggtitle(\"usando a função gam (REML)\")\n```\n\n-   Função \"ksmooth\" (suavização por regressão do núcleo)\n    -   Exemplo (atividade extraclasse): experimente um núcleo gaussiano (\"normal\") e diferentes larguras de banda (0.1, 10, 30).\n\n```{r}\nfit2 = ksmooth(t.day, y, kernel = c(\"box\"), bandwidth = 10)\n\nfit %>% \n broom::augment() %>% \n  mutate(\n    ksmooth_box = fit2$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_box), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (box)\")\n\n#\n#\n# kernel (“normal”) - bandwidth = 10\n\nfit3 = ksmooth(t.day, y, kernel = c(\"normal\"), bandwidth = 10)\n\nfit %>% \nbroom::augment() %>% \n  mutate(\n    ksmooth_normal = fit3$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_normal), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (normal|10)\")\n\n#\n#\n# kernel (“normal”) - bandwidth = 0.1\n\nfit4 = ksmooth(t.day, y, kernel = c(\"normal\"), bandwidth = 0.1)\n\nfit %>% \nbroom::augment() %>% \n  mutate(\n    ksmooth_normal = fit4$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_normal), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (normal|0.1)\")\n\n\n#\n# kernel (“normal”) - bandwidth = 0.1\n\nfit5 = ksmooth(t.day, y, kernel = c(\"normal\"), bandwidth = 30)\n\nfit %>% \nbroom::augment() %>% \n  mutate(\n    ksmooth_normal = fit5$y\n  ) %>% \n  ggplot(aes(t.day,y))+\n  geom_point()+\n  geom_line(aes(t.day, ksmooth_normal), color=\"red\", linewidth = 1.5)+\n  ggtitle(\"using ksmooth function (normal|30)\")\n```\n\n# 5 Resumo\n\n-   Explorou diversas funções de base.\n-   Realizou ajustes de curvas suaves utilizando o método dos mínimos quadrados ordinários (OLS).\n-   Discutiu o trade-off entre viés e variância, assim como a seleção do número de funções de base através da validação cruzada.\n-   Também realizou ajustes de curvas suaves utilizando o critério de erro quadrático penalizado.\n-   Por fim, foram discutidos diversos métodos para selecionar o parâmetro de suavização ótimo (λ).\n\nAtividades em Grupo / Atividades Extraclasse:\n\n1)  Página 2: Experimente diferentes números de funções de base e faça ajustes utilizando o método dos mínimos quadrados ordinários (atividade em grupo).\n2)  Página 3: Exercício de validação cruzada com medidas de precipitação transformadas em logaritmo obtidas em Quebec (atividade em grupo).\n3)  Página 4: Experimente as funções gam e ksmooth, especialmente a função gam, pois a utilizaremos nos capítulos seguintes! (atividade extraclasse).\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"dia02.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","editor":"visual","theme":"superhero","title":"Dia-02"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}