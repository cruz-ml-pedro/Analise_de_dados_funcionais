{
  "hash": "e760099c8eb036b3cb8c741824a57632",
  "result": {
    "markdown": "---\ntitle: \"Dia-03\"\n---\n\n::: {.cell}\n\n:::\n\n\n# Modelagem de Dados Funcionais usando Componentes Principais Funcionais {#secao-3}\n\n## Tópicos de hoje:\n\n-   FPCA para dados altamente frequentes (dados de imagens de tensor de difusão)\n\n    1.  Estimação das funções média e covariância (suavização de cada curva / média ponto a ponto)\n    2.  Decomposição espectral das funções de covariância (escalonamento!)\n\n-   FPCA para dados ruidosos e esparsos (dados de contagem de células CD4)\n\n-   Visualização usando refund.shiny (dados de clima canadense)\n\n## 1 FPCA para dados de alta frequentes com ruído.\n\n-   Modelo FPCA\n\n$$\nY_i(t) = \\mu(t) + \\sum_{k=1}^{n_{pc}} \\xi_{ik} \\phi_k(t) + \\epsilon_i(t)\n$$\n\nAqui vou usar o conjunto de dados de imagens de tensor de difusão (DTI) para ilustrar a análise de componentes principais funcionais para dados altamente frequentes com pequenos ruídos (sem dados faltantes).\n\nLembrando que, como discutido no Dia 1, iremos nos concentrar na Anisotropia Fracional (FA) ao longo do trato do corpo caloso (CCA) coletada de pacientes com esclerose múltipla (MS) sem nenhum valor faltante.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nDTI <- DTI %>% \n  drop_na() %>% \n  filter(visit == 1 & case == 1)\n\n\ncca_data <- DTI$cca %>% \n  t() %>% \n  as_tibble() %>% \n janitor::clean_names() %>% \n  mutate(\n    tract = 1:93\n  )\n```\n:::\n\n\ngráfico da média dos dados\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncca_data %>% \n  pivot_longer(cols = starts_with(\"x\")) %>% \n  group_by(tract) %>% \n  mutate(\n    avg = mean(value)\n  ) %>% \n  ggplot(aes(tract, value, group = name))+\n  geom_line(color = \"gray\")+\n  geom_line(aes(tract,avg), color = \"red\",linewidth = 2, linetype = 2)+\n  theme(legend.position = \"none\")+\n  ylab(\"Anisotropia fracional (AF)\")+\n  ggtitle(\"Imagem de Tensor de Difusão:CCA\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### 1.1 Estimação das funções média\n\nSuavize cada curva e calcule a média ponto a ponto.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mgcv)\n\nsmooth.curves <- array(0, dim(DTI$cca))\nn <- nrow(DTI$cca)\ntract <- 1:93\n\nfor(j in 1:n){\n  # j = 1\n  fit <- gam(DTI$cca[j,] ~ s(tract, k = 10, bs = 'cr'), method = \"REML\")\n  # plot(tract, DTI.baseline$cca[j,])\n  # lines(tract, fit$fitted)\n  smooth.curves[j,] <- fit$fitted\n}\n\n\nsmooth.curves %>% \n  t() %>% \n  as_tibble() %>% \n  janitor::clean_names() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>% \n  ggplot(aes(tract, value, group = name, color = name))+\n  geom_line()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsmooth.curves %>% \n  t() %>% \n  as_tibble() %>% \n  janitor::clean_names() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>% \n  mutate(\n    avg = mean(value)\n  ) %>% \n  ggplot(aes(tract, value, group = name))+\n  geom_line(color = \"gray\")+\n  geom_line(aes(tract,avg), color = \"red\",linewidth = 2, linetype = 2)+\n  theme(legend.position = \"none\")+\n  ylab(\"Anisotropia Fracional (FA)\")+\n  ggtitle(\"Imagem de Tensor de Difusão:CCA\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nObserve que ambas as abordagens fornecem exatamente a mesma função média!\n\n### 1.2 Estimação da função de covariância\n\nSuavize cada curva e calcule a covariância amostral.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(RColorBrewer)\n\nsmooth.cov <- cov(smooth.curves)\n\nsmooth.cov %>% \n  as_tibble() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  ggplot(aes(tract, name, fill = value)) + \n  geom_tile()+\n  scale_fill_gradientn(colors = brewer.pal(11, \"RdBu\")) +\n  theme(axis.text.y=element_blank(),\n        axis.ticks.y=element_blank())+\n  labs(y=tract,title = \"Covariância suavizada de Análise Fatorial (AF).\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### 1.3 A decomposição espectral da matriz de covariância estimada.\n\nA partir da decomposição espectral da função de covariância estimada, podemos obter as eigenfunções e os autovalores estimados.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsvd.result0 <- eigen(smooth.cov, symmetric = TRUE)\n# names(svd.result0)\n\nevectors <- svd.result0$vectors[,svd.result0$values > 0]\nevalues <- svd.result0$values[svd.result0$values > 0]\n\nhead(colSums(evectors^2)) # returns unitary vectors \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\n#Como as eigenfunções retornam vetores unitários, precisamos escalá-los por sqrt(93) (raiz quadrada de 93).\n\nefns0 <- evectors*sqrt(93)\nevals0 <- evalues/93\npve <- cumsum(evals0)/sum(evals0)\nnpc <- sum(pve < 0.95) + 1\n\n# Componentes eigen estimados truncados.\nefns <- efns0[,1:npc]\nevals <- evals0[1:npc]\n```\n:::\n\n\nO gráfico de \"scree\" está apresentado abaixo:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npve[1:20] %>% # existem 48 componentes / só estou usando as 20 primeiras\n  t() %>% \n  as_tibble() %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  mutate(\n    n_pcs = 1:20\n  ) %>%\n  ggplot(aes(n_pcs,value))+\n  geom_line()+\n  geom_point()+\n  geom_hline(yintercept = 0.95, color = \"red\", linetype = 2)+\n  labs(x= \"número de CPs\", y=\"% de variação explicada\", title = \"Scree plot\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nCom base no gráfico sabemos que os primeiros 5 componentes principais explicam mais de 95% das variabilidades nos dados.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nefns[,1:5] %>% \n  as_tibble() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>%\n  ggplot(aes(tract,value,group = name,color = name))+\n  geom_line()+\n  labs(y=\"autofunção\", title = \"5 primeiras autofunções\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nPodemos também visualizar o efeito de cada componente principal traçando a função $\\mu(t) \\pm 2\\sqrt{\\lambda_k}\\phi_k(t)$.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nk.pc <- 1\neffect <- efns[, k.pc]*2*sqrt(evals[k.pc])\nmean.hat <- colMeans(smooth.curves)\nmat <- cbind(mean.hat - effect,  mean.hat + effect)\n\n\nefns[, k.pc] %>% \n  as_tibble() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>%\n  ggplot(aes(tract,value))+\n  geom_line()+ggtitle(\"fPC1\")+\n  ylim(-2,2)\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\nmat %>% \n  as_tibble() %>% \n  cbind(pc_1 = mean.hat, tract = 1:93) %>% \n  pivot_longer(cols = 1:3) %>% \n  group_by(tract) %>% \n  ggplot(aes(tract, value, group = name, color = name))+\n  geom_line() +\n  ggtitle(glue::glue(\"fPC\",k.pc, \" (\",round(pve[k.pc]*100),\"%)\"))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-10-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n(Atividade em grupo) O que descobrimos a partir dos resultados da fPCA? Quanta variabilidade dos dados foi explicada pela primeira fPC? Que características das curvas a primeira fPC explica? Tente fazer os gráficos para a segunda e terceira fPCs e seus efeitos em relação à média geral.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nk.pc <- 2\neffect <- efns[, k.pc]*2*sqrt(evals[k.pc])\nmean.hat <- colMeans(smooth.curves)\nmat <- cbind(mean.hat - effect,  mean.hat + effect)\n\n\nefns[, k.pc] %>% \n  as_tibble() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>%\n  ggplot(aes(tract,value))+\n  geom_line()+ggtitle(glue::glue(\"fPC\",k.pc,))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\nmat %>% \n  as_tibble() %>% \n  cbind(pc_1 = mean.hat, tract = 1:93) %>% \n  pivot_longer(cols = 1:3) %>% \n  group_by(tract) %>% \n  ggplot(aes(tract, value, group = name, color = name))+\n  geom_line() +\n  ggtitle(glue::glue(\"fPC\",k.pc, \" (\",round(pve[k.pc]*100),\"%)\"))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-11-2.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\n#################################\n# Pc3\n\nk.pc <- 3\neffect <- efns[, k.pc]*2*sqrt(evals[k.pc])\nmean.hat <- colMeans(smooth.curves)\nmat <- cbind(mean.hat - effect,  mean.hat + effect)\n\n\nefns[, k.pc] %>% \n  as_tibble() %>% \n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>%\n  ggplot(aes(tract,value))+\n  geom_line()+ggtitle(glue::glue(\"fPC\",k.pc,))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-11-3.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\nmat %>% \n  as_tibble() %>% \n  cbind(pc_1 = mean.hat, tract = 1:93) %>% \n  pivot_longer(cols = 1:3) %>% \n  group_by(tract) %>% \n  ggplot(aes(tract, value, group = name, color = name))+\n  geom_line() +\n  ggtitle(glue::glue(\"fPC\",k.pc, \" (\",round(pve[k.pc]*100),\"%)\"))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-11-4.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### 1.4 Estimativa de escores e curvas ajustadas.\n\nOs escores estimados podem ser obtidos calculando $\\hat{\\xi}_{ik} = \\int_{T} \\hat{\\phi}^k(t) \\{Y_i(t) - \\hat{\\mu}(t)\\} dt$.\n\nE as curvas ajustadas são dadas por\n\n$$\n\\hat{Y}_i(t) = \\hat{\\mu}(t) + \\sum_{k=1}^{npc} \\hat{\\xi}_{ik} \\hat{\\phi}_k(t).\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndemeaned <- DTI$cca - t(matrix(rep(mean.hat, n),\n                                        nrow=length(mean.hat)))\n\nscores <- matrix(NA, nrow=n, ncol=npc)\nfitted <- array(NA, dim(DTI$cca))\n\nfor(i in 1:n){\n  scores[i,] <- colMeans(matrix(rep(demeaned[i,], npc), nrow=93) * efns)\n  fitted[i,] <- mean.hat + scores[i,]%*%t(efns)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrbind( DTI$cca[1:3,], fitted[1:3,])%>% \n  t() %>% \n  as_tibble() %>%\n  mutate(\n    tract = 1:93\n  ) %>% \n  pivot_longer(cols = contains(\"2\"), values_to = \"c_value\") %>% \n  pivot_longer(cols = starts_with(\"V\"), values_to = \"values_smoo\", names_to = \"name_smoo\") %>% \n  group_by(tract) %>% \n  ggplot(aes(tract,c_value, group = name, color=name))+\n  geom_point()+\n  geom_line(aes(tract,values_smoo,group = name_smoo, color = name_smoo), linewidth = 1.5)\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### 1.5 Funções já incorporadas disponíveis no R.\n\nExistem várias funções em R que implementam o método fPCA para dados densamente observados (com/sem ruído):\n\n-   `fpca.face`, `fpca.ssvd` e `fpca2s` do pacote \"refund\".\n    -   Desenvolvidas especificamente para dados funcionais densos.\n    -   Não são aplicáveis a dados funcionais esparsos.\n    -   `fpca.ssvd` e `fpca2s` exigem a especificação do número de componentes principais (npc); não é possível selecionar o número de componentes principais com base na proporção da variância explicada (PVE, sigla em inglês).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntract <- 1:93\n\nres.face <- fpca.face(Y = DTI$cca, argvals = tract, pve = 0.95)\n\nnames(res.face)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Yhat\"       \"Y\"          \"scores\"     \"mu\"         \"efunctions\"\n[6] \"evalues\"    \"npc\"       \n```\n:::\n\n```{.r .cell-code}\nefn.face <- res.face$efunctions*sqrt(93)\neval.face <- res.face$evalues/93\n\n\nefn.face %>% \n  as_tibble() %>% \n  rownames_to_column(var = \"tract\") %>% \n  mutate(\n    tract = as.numeric(tract)\n  ) %>% \n  dplyr::select(1:6) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(tract) %>% \n  ggplot(aes(tract, value, group = name,  color = name))+\n  geom_line()+\n  labs(x=\"tract\", y=\"\", title = \"5 primeiras autofunções\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nk.pc <- 1\nmu.hat <- res.face$mu\neffect <- efn.face[,k.pc] * 2* sqrt(eval.face[k.pc])\npve.face <- (cumsum(eval.face)/sum(eval.face))\n\npc1_plot <- cbind(tract, efn.face[,k.pc]) %>% \n  as_tibble()\n\npc1_plot %>% \n  ggplot(aes(tract, V2))+\n  geom_line()+\n  ylim(c(-2,2))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\nmu.hat %>% \n  as_tibble_col(column_name = \"mu.hat\") %>% \n  mutate(\n    effect_Plus = mu.hat + effect,\n    effect_less = mu.hat - effect,\n    tract = tract\n  ) %>% \n  pivot_longer(cols = 1:3) %>% \n  group_by(tract) %>% \n  ggplot(aes(tract, value, group = name, color = name))+\n  geom_line()+\n  ggtitle(glue::glue(\"fPC\", k.pc,\"(\", round(pve.face[k.pc]*100) ,\"%)\"))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-15-2.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\nyhat_smooth <- res.face$Yhat %>% \n      t() %>% \n      as_tibble() %>% \n     dplyr::select(1:3) %>% \n      pivot_longer(cols = contains(\"_1\")) %>% \n      rownames_to_column(var = \"tract\") %>% \n      mutate(\n        tract = as.numeric(tract)\n      ) %>% \n dplyr::select(-name)\n\nDTI$cca %>% \n  t() %>% \n  as_tibble() %>% \ndplyr::select(1:3) %>% \n  pivot_longer(cols = contains(\"_1\")) %>% \n  rownames_to_column(var = \"tract\") %>% \n  mutate(\n    tract = as.numeric(tract)\n  ) %>% \n  left_join(yhat_smooth, by = \"tract\") %>% \n  ggplot(aes(tract, value.x, group = name, color = name))+\n  geom_point(alpha = 0.7)+\n  geom_line(aes(tract,value.y), linetype = 1, linewidth = 1.5)\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-15-3.png){fig-align='center' width=100%}\n:::\n:::\n\n\nPara usar as funções `fpca.ssvd` e `fpca2s`, confira os seguintes códigos de exemplo:\n\n-   `res.ssvd <- fpca.ssvd(Y = DTI.baseline$cca, npc = 5)`\n\n-   `res.2s <- fpca2s(Y = DTI.baseline$cca, npc = 5, argvals = tract)`\n\n[Sempre verifique se os eigencomponentes e escores resultantes estão corretamente escalados!]{style=\"color:red\"}\n\n## 2 fPCA para dados ruidosos e esparsos.\n\nQuando queremos realizar a FPCA em dados funcionais esparsos e ruidosos, como o conjunto de dados de contagem de CD4...\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(cd4)\n\ncd4_tidy <- cd4 %>%\n  as_tibble() %>% \n  rowid_to_column(var = \"affected\") %>% \n  pivot_longer(cols = 2:62, names_to = \"months\", values_to = \"count-mm\" ) %>% \n  mutate(\n    months = as.numeric(months)\n  )\n\ncd4_tidy %>% \n  group_by(affected, months) %>%\n  drop_na() %>% \n  ggplot(aes(months, `count-mm`, group = affected))+\n  geom_line(color = \"grey\")\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\nset.seed(123)\nsampled <- sample(cd4_tidy$affected, size = 5, replace = FALSE)\n\ncd4_tidy %>% \n  filter(affected %in%  sampled) %>% \n  mutate(\n    affected = as_factor(affected)\n  ) %>% \n  group_by(affected, months) %>%\n  drop_na() %>% \n  ggplot(aes(months, `count-mm`, group = affected, color = affected))+\n  geom_line()+\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-16-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### 2.1 Análise de FPCA nos dados de contagem de células CD4.\n\nEstimativa da média através da combinação dos dados\n\nDevido ao fato de haver apenas algumas medições repetidas da contagem de células CD4 de cada sujeito, as duas abordagens para estimar a função média (e covariância) para dados funcionais densos não são apropriadas. Portanto, a abordagem comum para dados funcionais esparsos é combinar todas as medições.\n\nPor exemplo, para estimar a função média,\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn <- nrow(cd4)\nmonth <- as.numeric(colnames(cd4)) # months -18 and 42 since seroconversion\nm <- ncol(cd4)\n\n\nlibrary(mgcv)\n\n# use all measurements\ndat.vec <- data.frame(na.omit(cbind(rep(1:n, each = length(month)), \n                                    rep(month, n), as.vector(t(cd4)))))\ncolnames(dat.vec) <- c(\"id\", \"t\",\"y\")\nfit <- gam(y ~ s(t, k = 10, bs = \"cr\"), \n           method=\"REML\", data = dat.vec)\nmean.hat <- predict(fit, newdata = data.frame(\"t\" = month))\n\nmeand_df <- cbind(months =  unique(cd4_tidy$months), mean.hat) %>% \n  as_tibble()\n\n\nmeand_df %>% \n  ggplot(aes(months, mean.hat))+\n  geom_line()+\n  ylim(c(0,3000))\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nDa mesma forma, podemos estimar a função de covariância combinando todas as medições.\n\n### 2.2 FPCA usando funções incorporadas\n\nExistem vários softwares que já foram desenvolvidos para implementar o FPCA para dados funcionais esparsos e ruidosos.\n\n-   A função `fpca.sc` no pacote refund (documentação)\n-   A função `face.sparse` no pacote face (documentação)\n-   A função `fpca.mle` no pacote fpca (documentação)\n-   O pacote PACE (escrito em MATLAB) (página da web)\n\nA seguir, é apresentada uma ilustração de FPCA na contagem de células CD4 usando a função fpca.sc.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfpca.res <- fpca.sc(cd4, argvals = month, pve = 0.95, var = TRUE)\n#colSums(fpca.res$efunctions^2)\nm <- length(month)\n\nefns <- fpca.res$efunctions*sqrt(m)\nevals <- fpca.res$evalues/m\n\nefns %>% \n  as_tibble() %>% \n  mutate(\n    months = unique(cd4_tidy$months)\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  ggplot(aes(months, value, group = name, color = name))+\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\n#\nk.pc <- 2\nmean.hat <- fpca.res$mu\neffect <- 2*sqrt(evals[k.pc])*efns[,k.pc]\n\ncbind(mean.hat = mean.hat, effect = effect) %>% \n  as_tibble() %>% \n  mutate(\n    upper_bound = mean.hat + effect,\n    lower_bound = mean.hat - effect,\n    months = unique(cd4_tidy$months)\n  ) %>% \n  pivot_longer(cols = c(mean.hat,lower_bound,upper_bound)) %>% \n  ggplot(aes(months, value, group = name, color = name))+\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-18-2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n(Atividade em grupo) Discuta e interprete os resultados da FPCA. Quantos CPs são necessários para explicar 95% das variabilidades nos dados? Que características das curvas subjacentes foram capturadas por esses CPs?\n\nUsando as eigenfunções e escores estimados, também podemos reconstruir as curvas verdadeiras específicas do sujeito. As curvas ajustadas podem ser obtidas a partir dos resultados do fpca.sc, mas para fins de ilustração...\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#isso vem das linhas 521 e 522, onde foram calculadas as componentes\npve <- cumsum(evals)/sum(evals)\nnpc <- sum(pve < 0.95) + 1\n\n# truncated estimated eigen components\nefns <- efns[,1:npc]\nevals <- evals[1:npc]\n\n\n\npve[1:3] %>% # \n  t() %>% \n  as_tibble() %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  mutate(\n    n_pcs = 1:3\n  ) %>%\n  ggplot(aes(n_pcs,value))+\n  geom_line()+\n  geom_point()+\n  geom_hline(yintercept = 0.95, color = \"red\", linetype = 2)\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\n#\nfpca.res$Yhat %>%\n  t() %>% \n  as_tibble() %>% \n  mutate(\n    month = unique(cd4_tidy$months)\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(month) %>% \n  mutate(\n    avg = mean(value)\n  ) %>% \n  group_by(month) %>% \n  ggplot(aes(month, value, group = name, color = name))+\n  geom_line()+\n  theme(legend.position = \"none\")+\n  geom_line(aes(month, avg), color = \"red\", linewidth = 1, linetype = 2)\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-19-2.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\n#\nfpca.res$Yhat %>%\n  t() %>% \n  as_tibble() %>% \n  mutate(\n    month = unique(cd4_tidy$months)\n  ) %>% \n  pivot_longer(cols = starts_with(\"V\")) %>% \n  group_by(month) %>% \n  mutate(\n    avg = mean(value)\n  ) %>% \n  group_by(month) %>% \n dplyr::filter(name %in% c(\"V1\",\"V42\", \"V7\", \"V28\")) %>% \n  ggplot(aes(month, value, group = name, color = name))+\n  geom_line()+\n  theme(legend.position = \"none\")+\n  geom_line(aes(month, avg), color = \"red\", linewidth = 1, linetype = 2)\n```\n\n::: {.cell-output-display}\n![](dia03_files/figure-html/unnamed-chunk-19-3.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## 3 Visualização usando o pacote refund.shiny.\n\nA função principal no pacote refund.shiny é a função `plot_shiny`, que retorna gráficos interativos dos resultados de várias análises de dados funcionais:\n\n-   FPCA (dia 3)\n-   Regressão função-em-escalar (dia 4)\n-   FPCA variante no tempo (dia 5)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(cd4)\n```\n:::\n\n\nA função plot_shiny recebe a saída de qualquer uma das funções de FPCA no pacote refund, ou seja, fpca.sc, fpca.face, fpca.ssvd e fpca2s.\n\n`fpca.res <- fpca.sc(cd4, pve = 0.95, var = TRUE)`\n\n`plot_shiny(fpca.res)`\n\nIsso retorna cinco abas com gráficos interativos:\n\n-   Aba 1: média +/- CPs\n\n-   Aba 2: gráfico de \"scree\"\n\n-   Aba 3: combinações lineares\n\n-   Aba 4: ajustes por sujeito\n\n-   Aba 5: gráfico de dispersão de escores\n\n(Atividade em grupo) Explore os gráficos interativos.\n\n## 4 Resumo\n\n1)  Discutiu-se a estimativa de média e covariância para FD denso.\n2)  Interpretou-se os resultados da fPCA.\n3)  Exploraram-se gráficos interativos do plot_shiny.\n\nAtividades em grupo / para casa:\n\nAnalisar os dados da Maratona (atividade em grupo)\n\n(duas respostas: tempo decorrido com transformação logarítmica e tempo por milha)\n\n-   Plotar / descrever os dados.\n\n-   Plotar / discutir as funções estimadas de média e covariância.\n\n-   Utilizar gráficos interativos para explorar os resultados da fPCA e resumir suas descobertas.\n\nAnalisar os dados de Poluentes (atividade para casa)\n\n(enfoque no nível de sulfato com transformação logarítmica)\n\n-   Plotar / descrever os dados.\n\n-   Plotar / discutir as funções estimadas de média e covariância.\n\n-   Utilizar gráficos interativos para explorar os resultados da fPCA e resumir suas descobertas.\n",
    "supporting": [
      "dia03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}